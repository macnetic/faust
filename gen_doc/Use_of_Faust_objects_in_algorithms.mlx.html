<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2018b"><title>Using the FAµST API in Algorithms</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S2 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.2339992523193px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S3 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.2339992523193px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S4 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.2339992523193px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S5 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S6 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.2339992523193px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S7 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px 4px 0px 0px; padding: 6px 45px 4px 13px; line-height: 17.2339992523193px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S8 { color: rgb(64, 64, 64); padding: 10px 0px 6px 17px; background: rgb(255, 255, 255) none repeat scroll 0% 0% / auto padding-box border-box; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px; overflow-x: hidden; line-height: 17.2339992523193px;  }
.embeddedOutputsErrorElement {min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsErrorElement.inlineElement {}
.embeddedOutputsErrorElement.rightPaneElement {}
.embeddedOutputsWarningElement{min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsWarningElement.inlineElement {}
.embeddedOutputsWarningElement.rightPaneElement {}
.diagnosticMessage-wrapper {font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px;}
.diagnosticMessage-wrapper.diagnosticMessage-warningType {color: rgb(255,100,0);}
.diagnosticMessage-wrapper.diagnosticMessage-warningType a {color: rgb(255,100,0); text-decoration: underline;}
.diagnosticMessage-wrapper.diagnosticMessage-errorType {color: rgb(230,0,0);}
.diagnosticMessage-wrapper.diagnosticMessage-errorType a {color: rgb(230,0,0); text-decoration: underline;}
.diagnosticMessage-wrapper .diagnosticMessage-messagePart {white-space: pre-wrap;}
.diagnosticMessage-wrapper .diagnosticMessage-stackPart {white-space: pre;}
.embeddedOutputsTextElement,.embeddedOutputsVariableStringElement {white-space: pre; word-wrap: initial; min-height: 18px; max-height: 250px; overflow: auto;}
.textElement,.rtcDataTipElement .textElement {padding-top: 3px;}
.embeddedOutputsTextElement.inlineElement,.embeddedOutputsVariableStringElement.inlineElement {}
.inlineElement .textElement {}
.embeddedOutputsTextElement.rightPaneElement,.embeddedOutputsVariableStringElement.rightPaneElement {min-height: 16px;}
.rightPaneElement .textElement {padding-top: 2px; padding-left: 9px;}</style></head><body><div class = rtcContent><h1  class = 'S0'><span>Using the FAµST API in Algorithms</span></h1><div  class = 'S1'><span>After the little tour we've done in the previous live scripts, about the </span><a href = "#DEF8B9AF"><span style=' text-decoration: underline;'>creation of Faust objects</span></a><span>, and their </span><a href = "#DA705D65"><span style=' text-decoration: underline;'>manipulation</span></a><span>, we shall see in this third live script how the FAµST API can be deployed seamlessly in algorithms. Our example, already mentioned in the </span><a href = "#DA705D65"><span style=' text-decoration: underline;'>second live script</span></a><span>, will be the Orthogonal Matching Pursuit algorithm (OMP).</span></div><div  class = 'S1'><span>This algorithm comes up in the dictionary learning problem. Assuming that the reader is already familiar with this problem we will not treat the theory behind. There is not so much to say so let's go straight to the code example.</span></div><div  class = 'S1'><span style=' font-weight: bold;'>1. The Toy OMP Algorithm Implementation</span></div><div  class = 'S1'><span>You'll find the implementation we're talking about here: </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/tomp.mlx"><span>tomp.mlx</span></a><span>.</span></div><div  class = 'S1'><span>The most important point to notice in this code is that except the  import part in the header, all the code seems to be a natural Matlab implementation of OMP.</span></div><div  class = 'S1'><span>This is in fact the core philosophy of the FAµST API, as explained in  previous live scripts and also in the API documentation, we made sure that a Faust can be seen as a Matlab matrix. Hence this code is in fact totally compatible with the two APIs: the  function argument D, which is the dictionary, can be indifferently a mat</span><span style=' font-family: monospace;'>faust.Faust</span><span> object or a Matlab matrix.</span></div><div  class = 'S1'><span>A secondary point is that this implementation is more like a toy concept (as indicated by the "t" in the function name). A more advanced and  optimized version is introduced in the </span><a href = "#B7B767C5"><span style=' text-decoration: underline;'>last part of this live script</span></a><span>. In particular this version allows to define the algorithm stopping criterion according to the error tolerance the user wants.</span></div><div  class = 'S1'><span>Next we will test this implementation in both cases. But first, let us define a test case.</span></div><div  class = 'S1'><span style=' font-weight: bold;'>2. The Test Case Dictionary</span></div><div  class = 'S1'><span>For convenience, we shall set up a dictionary which guarantees uniqueness of sufficiently sparse representations. The dictionary is the concatenation of an identity matrix and a Hadamard matrix, and because we work with Faust objects, this concatenation will be a Faust object.</span></div><div  class = 'S1'><span>Below is the block matrix of our dictionary:</span></div><div  class = 'S1'><span style="vertical-align:-6px"><img src="data:image/png;base64,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" width="83.5" height="20" /></span></div><div  class = 'S1'><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAoCAYAAADg+OpoAAACHklEQVRYR+3WS6hNcRTH8c/NQJSkDDBhQgyYYIA8JsTAY0AijwkhETNCBjIxIKIoBp55lVchZopIJsqIklJKJAaUiJbWvh23e8/dZ59z7oC76wxO/c/67rPWb/1+/w599HT0EUc/qHKn/6/WDcB8LMFyDKnp2xVcxjX8LNPPMq0biAPYmgXPYAu+lAEUZ8qABuEQNuSPVuF8I5A4WwY0KgvPwUssxfN2gGbgTs7oKtbhcztA23EwC+/BfvxqNSiUdgyrs/A83G8UUmZGo3EB0/EIK/GmHaC5uJeFTyDa+K3VoFDkLuzLwhsRsEpPPXkPxcmU8zssxLNKlF72aHzazETcTUF8aAdoEW5k4XCGHfjealAYasxmZzO2U/tSPc1oOM6me1e2nTKgybiFkahsO2VAa3C6WdvpDdQ1fxbjZhcRhDUtwBTMxNFc7G2IfQsTjsz6VC+PJuEiJuSh2XjQjdoG4zCmIgCh0iIUp2EZXnQHGoHNuS/hccXzFNczk2p9rhDMV7zFEcSexZJHvEetj/X+UdlVKQQT59fjNsbhUn4i/jvvE2UStidwRPvxzKrdabbRvnNpW4UZ//l9VVBxj5iFtYj2Rq29uXsr8Lo31ZVpXZFTr2puRMNwCu8TOAZPmp1RcY8Ii4r2xSyKmUXsx/dQaqfbV21dBOAmxGI/zrcem7b1Iw34Ye3doiqoTHv/OtMParhlzaquYeC/N6PfQqtpKc+0RagAAAAASUVORK5CYII=" width="13" height="20" /></span><span> is the identity and</span><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAoCAYAAACFFRgXAAADA0lEQVRYR+2YS6hOURiGn5NSbhlgwEQGwuDIJeWSmCiUS5H7ZYCQIibItSQGLhkIpejIXeRSZCApJqJQIoNzGJBySYqI6K1va/X3r73X3mf/S6f2Gv5rfWu9//u96/2+tZvoYKOpg+GlAtzojFUMVwzXMJAmiS7AfGAMMBfo4cQ+Ay4DJ4DX9nt/YCEwExjlrP0EnASOAq/am4EQDXcFDgHL7bCrwErgvefw4cB5YCDwDlgE3Gkv0CS+COBZxq4Pw2jgtmXkCrAM+BwTcD/gNDARkBTmAC9SAIh9pV9jD7AN+B0T8DjgpjF2yaTxxQNAuj9oktGSGcC1ssBqnxBJuIyJrd3AHw8INxtP7LK+jAk4L2NuNk4Ba4CvMQHLqs4AY4EQxtYDBwzgBpNHmXgzJTHJbrwOzWJMPn0YWGysTgHul4o2Q8PS9xZgV4FDHwALnKJSYIv6IWmXridwHJhtjMl/H6ecPBVosfljgOTxvTSktlEa4MHABaAZuGtl960HQCfLxGabXwUIdOkjDfB0QGVYQ966CfjpQdDbND7ZyvE04FHpaFM0XMuY+gFVO98YCVwH+gK37OJ9iAk4L2MNLcfuH/dJIg9jtcVlnnVrjSDY68N5GHOLi/pducrThqD1aDhvOXaLi685ksTUCI0AhgFykzfAdvuDKjg7gR9Zf7SeJIYC54AhFjwBuOfZqJs5yAqbl2+vA77VWd/Hyrzm5DqqhLrI+23tEnOYVMwu4F7WFipwkBOlHlgt4kXrJzSVPIdkY+OdtWp0bgCqdGeBj86c9tRLRHYnB9kH6DWjXuUhsLEow1lZKTqf+LqaKGVEIJPubnWGbf47M6QfLgrQjXN9fS1wBPhl5Vvg5SxBFzUW4MTXpXlJrs3koMetujz1za58vCTFApz4uj4L7DB2B5jOVf51+boDz7PSGQuwvldIBirxyRsv0fRSu8Tq9JJvHP+V4c7AXnu16MNMq6HRhROzalm3hrCruFgMZ2U6eL4CHExVwYUVwwWJCw6rGA6mquDCvyWJnykIBjVWAAAAAElFTkSuQmCC" width="22" height="20" /></span><span>the orthonormal Hadamard matrix, with n being a power of two.</span></div><div  class = 'S1'><span>The condition on which the uniqueness of the sparse representation </span><span style=' font-style: italic;'>x</span><span> of a vector </span><span style=' font-style: italic;'>y</span><span> is ensured is defined by the following inequality:</span></div><div  class = 'S1'><span style="vertical-align:-15px"><img src="data:image/png;base64,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" width="108" height="53" /></span><span> where </span><span style=' font-style: italic;'>μ</span><span> denotes the coherence of the dictionary and in the case of our specially crafted dictionary </span><span style="vertical-align:-17px"><img src="data:image/png;base64,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" width="59" height="37" /></span><span>.</span></div><div  class = 'S1'><span>.</span></div><div  class = 'S1'><span>So let's construct the Faust of D, compute y for a sparse enough x  and test our OMP implementation to find out if we effectively retrieve this unique x as we should according to this theorem.</span></div><div  class = 'S1'><span>Note that, for a better view and understanding you might consult this article </span><a href = "#54CD7FD6"><span style=' text-decoration: underline;'>[1]</span></a><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>n = 128;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>FD = [ matfaust.eye(n), matfaust.wht(n) ];</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>D = full(FD)</span></span></div></div></div><div  class = 'S5'><span>Now that we have our dictionary both defined as a Faust (FD) and as a  matrix (D), let's construct our reference sparse vector x, we'll call it </span><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAoCAYAAAACJPERAAACU0lEQVRYR+3WSchOcRQG8N8nUSRJNgolGWKJTGFjSBFlHhZK2FAiipQyJkOGhYUiZaZEIlaUjbIghaVERMm0IFNH5+r6fMP7fl6xeG+93bfuOef5P88557m3wT+4Gv4BpjroX1W9Lm9d3pooUB+kmsjYXJH/Rt526IUpmIbRuIgVeM0Pvx6JHRiM5ThbjTRNMe2IvniGMTiJLpiI6xiHVfiEyViPg38KWs7vieMYn8UvYDU24EU1QOXY1nraIWUMZpeT3Sbcaytg5LUGGjHLcChBluIwvv1t0BG4hveYijvNALbHTMzFfQzBKZzD52rkjdgYqkgehoXZ48a4ARi9noHFeIBBOILz2IMvRVJr8sYkb82CkbMdG8sFstBwxJDtwt6UP2rHwM1P9j/noCXQeDYPo/ASMUBXsQivSlSL4ptznW6Wnk3I1oQKxWFaHKSQZ13++uEKnmff4tQ90hzi/zH0xmw8LIEOxBk8whK8aTy9sR6d8Q7dsQ8HcAvlfY2+hpTB7ESqEPfInZMABe4AnMaHlPlxGTQAo8jaTPqKLelGsR7R251Yibt4ks/Crfpn4bDIBelkBWifPNgvByp6GvdZWfht9i/YBHhxhd9GXzphW2kVCjZNgRYKdSur0Nr0VuIBTbLJxBblraR4czFd06UCoOpBaitwSyszFjdyt2Pff9hnLeSNOkOzx/sbmUO8KNZgOm5X6kiVsi9scFKax1PEbh/FJewu+2+tmMbhYq1iZeJrozD8+OKI9/HHag2/UrYVx9WSaR30NwXq8lY8FG0J/A5RFYIpFBaXRgAAAABJRU5ErkJggg==" width="14.5" height="20" /></span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>x0 = zeros(2*n, 1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nnz = floor(.5*(1+sqrt(n)));</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nonzero_inds = randperm(2*n);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nonzero_inds = nonzero_inds(1:nnz)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(34, 139, 34);">% we got nnz indices, now build the vector x0</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x0(nonzero_inds, 1) = abs(randn(size(nonzero_inds, 2), 1));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>disp(strcat(</span><span style="color: rgb(160, 32, 240);">'l0 norm of x0: '</span><span>, int2str(size(nonzeros(x0), 1))))</span></span></div></div></div><div  class = 'S5'><span>It remains to compute </span><span style=' font-style: italic;'>y</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>y = D*x0;</span></span></div></div></div><div  class = 'S5'><span>Our test case is complete, we are fully prepared to run the OMP algorithm using a well-defined dictionary as a Faust or as numpy array, this should retrieve our </span><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAoCAYAAAB0HkOaAAACY0lEQVRYR+3WS+hNURTH8c9fokiSTBRK8ogh8goTjxRR3o+BEiaUiCKlPJNHHgMDRcqbEokYUSbKgBSGEhElrwF5tbRPnf7uvef+OUKdW7dza5+71nf/1m+tvVv8Q5+Wf4hFBVOvGpUylTJt7dTKM5VnKs+0VYG2eKYdemEKpmE0LmIFXvPjPBuJHRiM5ThbBlCt1u6IvniGMTiJLpiI6xiHVfiEyViPg38KJh+3J45jfEp6AauxAS/KAMjHKBp6HVI5QonLSY1NuFc2SMQrgol3luFQSr4Uh/Htb8GMwDW8x1TcqQPSHjMxF/cxBKdwDp+bgW9GmTBzBB2GhclDrWMHSHhpBhbjAQbhCM5jD74UARXBRGdtTYki1nZsrBF4OMLcu7A3lTFih9HnJ7UKfdYIJtbmYRReIox7FYvwKrfLLOnm1PY3c2sTUolDtQyyrkCNYELmdenbD1fwPPkidtkjDb34fQy9MRsPc9kG4gweYQneNCpVHibauDPeoTv24QBuIT9vwjdRklDiRFItnvHfOSlxlnMATuNDKtfjZmACJIKvTcG+YkuavtHG4Z2dWIm7eJLWYjr3TwnjqFiQJneWs08CrgX6E1emTDxnpYRvkz9i9wGVfeI8irp3wrZcy2a7rwWTKdqthmp1YYq6rtF6o93/Upl+B6ZrmsqRuDQD/ypQo9YeixtpNsW8aniMFA29ZgGHJg/tbzX04oBdg+m4XRSsLJjsOJiUhuJTxGw6ikvY3cz5VBZMbDraP1o7bofZQRk3xLgPfSxSpdkrRDNxSnmnTGV+G6iCqSdhpcx/ocx3PbiCKRFBISwAAAAASUVORK5CYII=" width="17.5" height="20" /></span><span>from the vector y. Let's try!</span></div><div  class = 'S1'><span style=' font-weight: bold;'>3. Running the Algorithm</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>x = tomp(y, FD, nnz);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nonzeros(x)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nonzeros(x0)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>[</span><span class="warning_squiggle_rte warningHighlight">I</span><span>, ~, ~] = find(x-x0)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>[I, ~, ~] = find(x)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>assert(all(x-x0 &lt; 10^-6));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>disp(</span><span style="color: rgb(160, 32, 240);">'We succeeded to retrieve x0, OMP works!'</span><span>)</span></span></div></div></div><div  class = 'S5'><span>We tested OMP on a Faust, go ahead and verify what we was aiming at in the first part of the live script: is this OMP implementation really working identically on a Faust and a real array.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>x = tomp(y, D, nnz);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>assert(all(x-x0 &lt; 10^-6));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>disp(</span><span style="color: rgb(160, 32, 240);">'We succeeded to retrieve x0, OMP works!'</span><span>)</span></span></div></div></div><div  class = 'S5'><span>We can conclude that the algorithm is indeed available to both Matlab array and Faust worlds, and we can imagine surely that other algorithms are reachable through the FAµST API. That's anyway in that purpose that the FAµST library will be extended if needed in the future.</span></div><div  class = 'S1' id = 'B7B767C5' ><span style=' font-weight: bold;'>4. An OMP-Cholesky Implementation</span></div><div  class = 'S1'><span>Speaking of the OMP algorithm and the possibility to implement other optimization algorithms with FAµST, it would be a pity not to mention that the library is delivered with another implementation of OMP.</span></div><div  class = 'S1'><span>This implementation is actually an optimized version which takes advantage of the Cholesky factorization to simplify the least-square problem to solve at each iteration. This algorithm is implemented into the </span><span style=' font-family: monospace;'>tools</span><span> module of matfaust.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>import </span><span style="color: rgb(160, 32, 240);">matfaust.tools.omp</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>help </span><span style="color: rgb(160, 32, 240);">matfaust.rand</span></span></div></div></div><div  class = 'S5'><span>This implementation is integrated into matfaust as a tool for the Brain Source Localization (BSL) demo which is documented </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classmatfaust_1_1demo_1_1bsl.html"><span style=' text-decoration: underline;'>here</span></a><span>.</span></div><div  class = 'S1'><span>To show off a little, let's run this demo.</span></div><div  class = 'S1'><span style=' font-weight: bold;'>Warning</span><span>: the demo takes a few minutes.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>matfaust.demo.bsl.BSL()</span></span></div></div></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>matfaust.demo.bsl.Fig_BSL()</span></span></div></div></div><div  class = 'S5'><span>What we see in this figure is that it takes a few dozens of milliseconds (the median time) to compute the BSL experiment on the dense matrix M.  This is well above the time it takes with Faust approximates</span><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAuCAYAAAC1ZTBOAAAEjklEQVRYR+2YaahVZRSGH8tyiDBwLiyKwiE00B/9CNE/zRHZnENJMxVkZWaFJc0EFUVhRWAjlRWCFUKpDSSaGGogGf1IwSIpioqMokEeWN/hu5uzz9nn3HM5XLjr17377P2td6/hXe/ag+gHNqgfYGQAZKey1MlIjgYeAxYAy4FHgT87AbRTICcBTwKnZaBeAW4Dfuwt0N6C9PlZwLOAkXwAWA3cCCwGPgBuBnb1BmhvQA4G5gGPA1uBO4FtwP/AQcCZkX7xXQ98Er+1jLddkMOAJZHO+4AVwB91vBtd6/NS4FbgNeCfVlG2A3JcNMVxwCLgiyYRMqrnRym83k5DtQryEGAaMBTYXhK9skCNBKYAPwNfAf9VjWirIKue29H7+j3IIcBFwFnAOcDhEZ7ngFsqEvUJgHx5cjxrqt+KRttRNdxVImknPwFcF4e+H1PllyZOfM6pc1N2n9PIDpemKlsVkCOAF4AL49R1wNwKk0TaeT7LwOfAZcC3ldHFjVVA2s1vA6ZOM02XAF83cJbSfDQwvo0y6XF0FZBOlbuBn4CZwO8xozeXgExpngBYEgvjPsncsmnZmoE8FHgEGA78BtweHhQSH5Z4M81OoTuAa4Ez4sUckxtbRghNRe+RUehvRDe/FE7mx/Wiz5Tmd4BPQ2yY7o9jzn/fFyBPCTAXAMcDgtXuAh4uOExpPiqYwFGoOtJM81Lg774AKR+aWqljIvBZOBHgMuDfzGlK8zXApigTn9fKIl8Jc6OalLyfAfYGIFO5CpgKFAk9pVktqTofExmYDXwT9PVlJUR1bmoE0si9CdwDrMnSPQPICT3vZgl/H2CZrA2OlL6uBn7tC5Dnhry6OJS1KsZpcXqhEUyzDHAlsCGAmGbFsGZZPNjqlMlfqCySBwP3B4GnKEhD7jH+nwhdueVsfi+AKmhTmVjHWiO68ncVvrPdiebfZs3ary1xZSBHhXN5LUVBDWm93RC8Nwc4Dzg2gP8QoBILWBbNptMx0fmHFdaPHpVRBlIH7wJXFEjb1EnU2qtZ57twJTs1FjD/N8ouZU6pok0GVgK+XKrlumVbBtKHLg8hsSd70muJ0L38EHBvtrd4niPUUtHKRqG7jwwxPdLsIldq9UAa+qfDsevo/uxphUUi9I+CP7/Lfs8Vk9ErG4VXhbJ6Kha6v1oFeWIIU5emFJF0htRiUQvAQs/T7D25YiobhfmLmG7Hpuc6Ml8Meac4rlkxknaX40tw9aaKXyokdMGZ1jwCKnlT7/6tlenOxL9um1KVte1G6VSyMa1j1+XaipyDPClUtCmVRoyWZG5614djO1e1ba3tjmtHxF59dqwZeRCkJl/IF5PktZSNIsmnMlMnyBzJZ1MV1KhU2v0tgay3K6Uh0KPhmunJdoE0ei6VjOtEsTEV2KbfUVzrh26ATI1jmRR3pQRSfn45vWk3QOrTtPrVzYm1JcB43cZTK7hK7+wmSH2PDTKXY1MnK5btbNWT4qSmVbsRyRQgP3z5kVUt6nclqckPBwqMHl/eugmyclMOgKwcqiY3DkRyIJKdikCnzjkA2RYAPo35F6QAAAAASUVORK5CYII=" width="20.5" height="23" /></span><span>to</span><span style="vertical-align:-6px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAuCAYAAACF6SFvAAAFN0lEQVRoQ+2ZV6gkZRCFvzUHRGHXnFAUEyrog4iIvpjFHNecRcWcxYAZMWDCyK5rYM2CEcyKYkAxIaYHFVRMKCpGTHxQNfy36b4zu9PNyHp/WNg7M91dp+pU1anqScxBZ9IchIUJMP/VaHYdmcWBy4B9gHOAS4Bfu3JGl2BWB64ENi+Mvw04AfimC0BdgPGemwDXA0bmfOAB4EjgROBx4Bjg/bYBtQ1mHmAv4HLgNeA04A3gH2AuYKugnTgOB56L71rB1SaYBYGTg0bnAtcBP9dYabTMnz2A44E7gD/bQNMWmKUiuVcGjgVe7+Nxo7RTUHBmW4WhDTDzAusACwBvNkSjyfGTgTWB74D3gL+HiVAbYIZ5fqvX/m/AzA/sCmwNbAssEm68AThuwOa3KmBv2SCulU73RHF4q9WwwEDazCp1BXBYPPyR6Ojf9zHG6+z4RxW/UwlYvSzVrZ9BaLYocDOwSzz9SWDqAF3c0ntjEdFXgD2Bj1tHETccBIyV6l5Aynikx+7AB+MYlfRaAVh6Nug5W3gHAWNHPwP4FtgY+Cn01ssNT0x6LQ9Ixf3jdzZI6drZ6QdmPuBiYCHgR+CksETx+ESDVdJLBXAKcCiwZThAKfNiZ0gGKADLRMLeGdVrRhizd3xetS3pdR/wfAhMafZsaLYvRglmozB6Z2AVQFCe04GLKoYlvZaNyqdcUTl7pNepwB+jBGM/kVKW1NWAF8IYgZwJ/FUYl/Q6BHgp6On1nqZItoptvJyxSV4LfBaGS6G7gbWBauNMejm3OFkuERHdFPgoyvrbrVpec7PxwBiJu4CzgAcLmq0PlI2zrF421q8A6flY9BjL+sHAD6MEs11I9N1iKlTh2r23qCS09LLiHQg8HQZLLwc0j3S8oKuuXzqoKTJzA+dFo0yvWp6d6f07G6eSXe31cAByyEp6mmeepjIuXY+O3uX4oLLw/u80RNApVo2nEvH/ssUc7i1ImsBMCSPtC+lVH2g+HBF9Y0dgB2ClAPhlGJFVTzo2qQVpaIVzMPswyrZSR8lzQMw2JaYV4/cLV0bxMbibwGjIQ8B+leYoZWyIntuLSueSIs9msbTwb6PmIkPVkEeDdIpA3AF49LSlWzZUabkGMB3QWZmTtcFrAuNF+4ag/LS40s+ycfrxhcDZxQzv/ZQ+GuWpkzAWFqN6aWX2TwdKnxwx3BdYOdcLerkkaTx1YPTcNfEgV0K/FFcrMLNxPhP95/Pi+1JhG406CWMU/Pdbxaqsno8WPeygUOxXxbLk91kFs1YMUNIgPZz3kOsmnYaaiCW9/E2psGdVwmRknH/uB0rHSDNlkc9XEt0S44XDXu9UI1Nyt67Lu6W0cQpCOpWecjKVcu7KPIPOPWmMUbAdqCC+DsVhn3PjI+3MUbc6qglzznx0tdVbZ5Vg1o2pUCpZXvW+N5NWT8UTrVROj+bCJ/HZYrED2ybG69JZlmyB6wCbadNxVXV10DuLQrKg2nQzDdSL5l7aNtDYPB5N2/hONugcZZPUzpE6wdTtHLIpjykw/eaZNoztl7P2l+VCMZSbzaS0vadaiBwYpZ1Sq5fXowbjgn37qF7VVW4WAGlc3TkkGPvgremtUYLZMBSEbwnKpmr+uNqaFqte3xyoNF4No7XZQqNmdBX27qjB2NVvAtwjlO9q1ITuGWyoJvaS0TTtZVm5HP6sZKpyxWxvphpFZMwPJ1CrX91xJrJM517OSPmCypnJXbbN1UWiSmHM24NRgOmsqEyA6cy1Q954IjJDOrCzyyci05lrh7zxv4SULT4h+WOWAAAAAElFTkSuQmCC" width="25.5" height="23" /></span><span> in which the numbers 6 and 26 denote the Faust </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classmatfaust_1_1Faust.html#aff3261319b63c49d51a699726edc74bc"><span style=' text-decoration: underline;'>RCG</span></a><span>. The greater the RCG the better the computation time is, as we already saw in the live script</span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Use_of_Faust_objects_in_algorithms.html#manip_links"><span style=' text-decoration: underline;'> about Faust manipulations</span></a><span>.</span></div><div  class = 'S1'><span>As a complementary test, let's verify that the two runs of </span><span style=' font-family: monospace;'>omp()</span><span> on FD and D we constructed before for the toy OMP give the same results even if the vector to retrieve is not very sparse. Here for instance, </span><span style="vertical-align:-6px"><img src="data:image/png;base64,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" width="74.5" height="20" /></span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>import </span><span style="color: rgb(160, 32, 240);">matfaust.tools.omp</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nnz = 98;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x1 = zeros(2*n, 1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nnz_inds = randperm(2*n);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nnz_inds = nnz_inds(1:nnz);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x1(nnz_inds, 1) = randn(size(nnz_inds,2),1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>y = FD*x1;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x2 = omp(y, D, </span><span style="color: rgb(160, 32, 240);">'maxiter'</span><span>, nnz);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x3 = omp(y, FD, </span><span style="color: rgb(160, 32, 240);">'maxiter'</span><span>, nnz);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>disp([</span><span style="color: rgb(160, 32, 240);">'Are x2 and x3 solutions almost equal? ' </span><span>int2str(norm(x2-x3)/norm(x3) &lt; 10^-12) ])</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>disp([</span><span style="color: rgb(160, 32, 240);">'Is x1 retrieved into x2? ' </span><span>int2str(all(x1-x2 &lt; 10^-6)) ])</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>disp([</span><span style="color: rgb(160, 32, 240);">'Is x1 retrieved into x3? ' </span><span>int2str(all(x1-x3 &lt; 10^-6)) ])</span></span></div></div></div><div  class = 'S5'><span>As expected, we didn't retrieve our starting x1 (the reason is the condition already discussed in 2. However let's mention that here again (like it was with the toy OMP) it works the same with the Faust API or with Matlab arrays.</span></div><div  class = 'S1'><span>Finally, let's check the computation time for applying our dictionary to a vector both for the Matlab and Faust versions. Although, in order  to avoid major differences in results calculated on distinct computer configurations the comparison is performed on a larger dimension than  before.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>n = 1024;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>FD = [ matfaust.eye(n) matfaust.wht(n) ];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>D = full(FD);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>x = rand(2*n, 1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>timeit(@() D*x)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>timeit(@() FD*x)</span></span></div></div></div><div  class = 'S5'><span>On smaller dimensions it's possible on particularly slow machines to obtain a slower FD multiplication comparatively to the D multiplication.</span></div><div  class = 'S1'><span>This is essentially because the speedup offered by Faust appears rather for higher matrix dimensions.</span></div><div  class = 'S1'><span>Let us illustrate the speedup more generally by repeating the experiment for various dimensions n.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>figure()</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>d_times = [];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>fd_times = [];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>dims = [];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>num_muls = 10;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(0, 0, 255);">for </span><span>n=2.^(8:12)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    FD = [ matfaust.eye(n) matfaust.wht(n) ];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    D = full(FD);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    x = randn(2*n, 1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span class="warning_squiggle_rte">dims</span><span> = [dims n];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    t=tic;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span style="color: rgb(0, 0, 255);">for </span><span>i=1:num_muls</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>        D</span><span class="warning_squiggle_rte">*</span><span>x;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span style="color: rgb(0, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span class="warning_squiggle_rte">d_times</span><span> = [ d_times toc(t)];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    t=tic;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span style="color: rgb(0, 0, 255);">for </span><span>i=1:num_muls</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>        FD</span><span class="warning_squiggle_rte">*</span><span>x;</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span style="color: rgb(0, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>    </span><span class="warning_squiggle_rte">fd_times</span><span> = [ fd_times toc(t)];</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(0, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>semilogy(dims, fd_times, dims, d_times);</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>legend(</span><span style="color: rgb(160, 32, 240);">"FD*x times"</span><span>, </span><span style="color: rgb(160, 32, 240);">"D*x times"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>xlabel(</span><span style="color: rgb(160, 32, 240);">"dimension"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>ylabel(</span><span style="color: rgb(160, 32, 240);">"time"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>title(</span><span style="color: rgb(160, 32, 240);">"D*x and FD*x time comparison"</span><span>)</span></span></div></div></div><div  class = 'S5'><span>As shown for dimensions n above 1024 an actual speedup occurs, the  speedup figure below confirms this result. Improving such a speedup and decreasing the dimensions where it occurs is part of the roadmap for future developments of matfaust.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S2'><span style="white-space: pre;"><span>scatter(dims, d_times./fd_times)</span></span></div></div><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>legend(</span><span style="color: rgb(160, 32, 240);">'speedup'</span><span>) </span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>title(</span><span style="color: rgb(160, 32, 240);">"Speedup factor of FD*x relatively to D*x"</span><span>)</span></span></div></div></div><div  class = 'S1'><span style=' font-weight: bold; font-style: italic;'>The third live script is ending here</span><span>, I hope  you'll be interested in trying yourself to write another algorithm with  the FAµST API and maybe discovering any current limitation. Don't  hesitate to </span><a href = "http://https//faust.inria.fr/contact/"><span>contact</span></a><span> us in that case, we'll appreciate any feedback!</span></div><div  class = 'S1'><span style=' font-weight: bold;'>Links</span></div><div  class = 'S1' id = 'DEF8B9AF' ><span>Faust creation (1st) live script: </span><span> </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_creation.mlx.html"><span style=' text-decoration: underline;'>html</span></a><span>, </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_creation.mlx"><span style=' text-decoration: underline;'>mlx</span></a></div><div  class = 'S1' id = 'DA705D65' ><span>Faust manipulation (2nd) live script:</span><span> </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_manipulation.mlx.html"><span style=' text-decoration: underline;'>html</span></a><span>, </span><a href = "https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_manipulation.mlx"><span style=' text-decoration: underline;'>mlx</span></a></div><div  class = 'S1' id = '54CD7FD6' ><span>[1]</span><span> </span><a href = "http://doi.org/10.1109/TIT.2004.834793"><span style=' text-decoration: underline;'>Tropp, J. A. (2004). Greed is Good: Algorithmic Results for Sparse  Approximation. IEEE Transactions on Information Theory, 50(10),  2231–2242</span></a><span>.</span></div><div  class = 'S1'><span></span></div><div  class = 'S1'><span style=' font-weight: bold;'>Note:</span><span> this livescript was executed using the following matfaust version:</span></div><div class="CodeBlock"><div class="inlineWrapper outputs"><div  class = 'S7'><span style="white-space: pre;"><span>matfaust.version()</span></span></div><div  class = 'S8'><div class="inlineElement eoOutputWrapper embeddedOutputsVariableStringElement" uid="E5C40B01" data-testid="output_0" data-width="1180" data-height="20" data-hashorizontaloverflow="false" style="width: 1210px; max-height: 261px;"><div class="textElement"><div><span class="variableNameElement">ans = </span>'3.27.2'</div></div></div></div></div></div></div><br>
<!-- 
##### SOURCE BEGIN #####
%% Using the FAµST API in Algorithms
% After the little tour we've done in the previous live scripts, about the <internal:DEF8B9AF 
% creation of Faust objects>, and their <internal:DA705D65 manipulation>, we shall 
% see in this third live script how the FAµST API can be deployed seamlessly in 
% algorithms. Our example, already mentioned in the <internal:DA705D65 second 
% live script>, will be the Orthogonal Matching Pursuit algorithm (OMP).
% 
% This algorithm comes up in the dictionary learning problem. Assuming that 
% the reader is already familiar with this problem we will not treat the theory 
% behind. There is not so much to say so let's go straight to the code example.
% 
% *1. The Toy OMP Algorithm Implementation*
% 
% You'll find the implementation we're talking about here: <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/tomp.mlx 
% tomp.mlx>.
% 
% The most important point to notice in this code is that except the  import 
% part in the header, all the code seems to be a natural Matlab implementation 
% of OMP.
% 
% This is in fact the core philosophy of the FAµST API, as explained in  
% previous live scripts and also in the API documentation, we made sure that a 
% Faust can be seen as a Matlab matrix. Hence this code is in fact totally compatible 
% with the two APIs: the  function argument D, which is the dictionary, can be 
% indifferently a mat|faust.Faust| object or a Matlab matrix.
% 
% A secondary point is that this implementation is more like a toy concept 
% (as indicated by the "t" in the function name). A more advanced and  optimized 
% version is introduced in the <internal:B7B767C5 last part of this live script>. 
% In particular this version allows to define the algorithm stopping criterion 
% according to the error tolerance the user wants.
% 
% Next we will test this implementation in both cases. But first, let us 
% define a test case.
% 
% *2. The Test Case Dictionary*
% 
% For convenience, we shall set up a dictionary which guarantees uniqueness 
% of sufficiently sparse representations. The dictionary is the concatenation 
% of an identity matrix and a Hadamard matrix, and because we work with Faust 
% objects, this concatenation will be a Faust object.
% 
% Below is the block matrix of our dictionary:
% 
% $$D=\;\lbrack \;I_n \mid H_n \rbrack \;$$
% 
% $I_n$ is the identity and$H_n \;$the orthonormal Hadamard matrix, with 
% n being a power of two.
% 
% The condition on which the uniqueness of the sparse representation _x_ 
% of a vector _y_ is ensured is defined by the following inequality:
% 
% $\|\;x\;{\left\|\right.}_0 <\frac{\left(1+\frac{1\;}{\mu }\right)}{\;2}$ 
% where _μ_ denotes the coherence of the dictionary and in the case of our specially 
% crafted dictionary $\mu =\frac{1\;}{\;\sqrt{\;n}}$.
% 
% .
% 
% So let's construct the Faust of D, compute y for a sparse enough x  and 
% test our OMP implementation to find out if we effectively retrieve this unique 
% x as we should according to this theorem.
% 
% Note that, for a better view and understanding you might consult this article 
% <internal:54CD7FD6 [1]>.

n = 128;
FD = [ matfaust.eye(n), matfaust.wht(n) ];
D = full(FD)
%% 
% Now that we have our dictionary both defined as a Faust (FD) and as a  
% matrix (D), let's construct our reference sparse vector x, we'll call it $x_0$.

x0 = zeros(2*n, 1);
nnz = floor(.5*(1+sqrt(n)));
nonzero_inds = randperm(2*n);
nonzero_inds = nonzero_inds(1:nnz)
% we got nnz indices, now build the vector x0
x0(nonzero_inds, 1) = abs(randn(size(nonzero_inds, 2), 1));
disp(strcat('l0 norm of x0: ', int2str(size(nonzeros(x0), 1))))
%% 
% It remains to compute _y_.

y = D*x0;
%% 
% Our test case is complete, we are fully prepared to run the OMP algorithm 
% using a well-defined dictionary as a Faust or as numpy array, this should retrieve 
% our $x_0 \;$from the vector y. Let's try!
% 
% *3. Running the Algorithm*

x = tomp(y, FD, nnz);
nonzeros(x)
nonzeros(x0)
[I, ~, ~] = find(x-x0)
[I, ~, ~] = find(x)
assert(all(x-x0 < 10^-6));
disp('We succeeded to retrieve x0, OMP works!')
%% 
% We tested OMP on a Faust, go ahead and verify what we was aiming at in 
% the first part of the live script: is this OMP implementation really working 
% identically on a Faust and a real array.

x = tomp(y, D, nnz);
assert(all(x-x0 < 10^-6));
disp('We succeeded to retrieve x0, OMP works!')
%% 
% We can conclude that the algorithm is indeed available to both Matlab 
% array and Faust worlds, and we can imagine surely that other algorithms are 
% reachable through the FAµST API. That's anyway in that purpose that the FAµST 
% library will be extended if needed in the future.
% 
% *4. An OMP-Cholesky Implementation*
% 
% Speaking of the OMP algorithm and the possibility to implement other optimization 
% algorithms with FAµST, it would be a pity not to mention that the library is 
% delivered with another implementation of OMP.
% 
% This implementation is actually an optimized version which takes advantage 
% of the Cholesky factorization to simplify the least-square problem to solve 
% at each iteration. This algorithm is implemented into the |tools| module of 
% matfaust.

import matfaust.tools.omp
help matfaust.rand
%% 
% This implementation is integrated into matfaust as a tool for the Brain 
% Source Localization (BSL) demo which is documented <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classmatfaust_1_1demo_1_1bsl.html 
% here>.
% 
% To show off a little, let's run this demo.
% 
% *Warning*: the demo takes a few minutes.

matfaust.demo.bsl.BSL()
%%
matfaust.demo.bsl.Fig_BSL()
%% 
% What we see in this figure is that it takes a few dozens of milliseconds 
% (the median time) to compute the BSL experiment on the dense matrix M.  This 
% is well above the time it takes with Faust approximates$\hat{M_6 }$to$\hat{M_{26} 
% }$ in which the numbers 6 and 26 denote the Faust <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/classmatfaust_1_1Faust.html#aff3261319b63c49d51a699726edc74bc 
% RCG>. The greater the RCG the better the computation time is, as we already 
% saw in the live script<https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Use_of_Faust_objects_in_algorithms.html#manip_links  
% about Faust manipulations>.
% 
% As a complementary test, let's verify that the two runs of |omp()| on FD 
% and D we constructed before for the toy OMP give the same results even if the 
% vector to retrieve is not very sparse. Here for instance, $\left\|\;x_1 \;{\left\|\right.}_0 
% =98\right.$.


import matfaust.tools.omp
nnz = 98;
x1 = zeros(2*n, 1);
nnz_inds = randperm(2*n);
nnz_inds = nnz_inds(1:nnz);
x1(nnz_inds, 1) = randn(size(nnz_inds,2),1);
y = FD*x1;
x2 = omp(y, D, 'maxiter', nnz);
x3 = omp(y, FD, 'maxiter', nnz);
disp(['Are x2 and x3 solutions almost equal? ' int2str(norm(x2-x3)/norm(x3) < 10^-12) ])
disp(['Is x1 retrieved into x2? ' int2str(all(x1-x2 < 10^-6)) ])
disp(['Is x1 retrieved into x3? ' int2str(all(x1-x3 < 10^-6)) ])
%% 
% As expected, we didn't retrieve our starting x1 (the reason is the condition 
% already discussed in 2. However let's mention that here again (like it was with 
% the toy OMP) it works the same with the Faust API or with Matlab arrays.
% 
% Finally, let's check the computation time for applying our dictionary to 
% a vector both for the Matlab and Faust versions. Although, in order  to avoid 
% major differences in results calculated on distinct computer configurations 
% the comparison is performed on a larger dimension than  before.

n = 1024;
FD = [ matfaust.eye(n) matfaust.wht(n) ];
D = full(FD);
x = rand(2*n, 1);
timeit(@() D*x)
timeit(@() FD*x)
%% 
% On smaller dimensions it's possible on particularly slow machines to obtain 
% a slower FD multiplication comparatively to the D multiplication.
% 
% This is essentially because the speedup offered by Faust appears rather 
% for higher matrix dimensions.
% 
% Let us illustrate the speedup more generally by repeating the experiment 
% for various dimensions n.

figure()
d_times = [];
fd_times = [];
dims = [];
num_muls = 10;
for n=2.^(8:12)
    FD = [ matfaust.eye(n) matfaust.wht(n) ];
    D = full(FD);
    x = randn(2*n, 1);
    dims = [dims n];
    t=tic;
    for i=1:num_muls
        D*x;
    end
    d_times = [ d_times toc(t)];
    t=tic;
    for i=1:num_muls
        FD*x;
    end
    fd_times = [ fd_times toc(t)];
end
semilogy(dims, fd_times, dims, d_times);
legend("FD*x times", "D*x times")
xlabel("dimension")
ylabel("time")
title("D*x and FD*x time comparison")
%% 
% As shown for dimensions n above 1024 an actual speedup occurs, the  speedup 
% figure below confirms this result. Improving such a speedup and decreasing the 
% dimensions where it occurs is part of the roadmap for future developments of 
% matfaust.

scatter(dims, d_times./fd_times)
legend('speedup') 
title("Speedup factor of FD*x relatively to D*x")
%% 
% _*The third live script is ending here_*, I hope  you'll be interested 
% in trying yourself to write another algorithm with  the FAµST API and maybe 
% discovering any current limitation. Don't  hesitate to <http://https//faust.inria.fr/contact/ 
% contact> us in that case, we'll appreciate any feedback!
% 
% *Links*
% 
% Faust creation (1st) live script:  <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_creation.mlx.html 
% html>, <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_creation.mlx 
% mlx>
% 
% Faust manipulation (2nd) live script: <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_manipulation.mlx.html 
% html>, <https://faustgrp.gitlabpages.inria.fr/faust/last-doc/html/Faust_manipulation.mlx 
% mlx>
% 
% [1] <http://doi.org/10.1109/TIT.2004.834793 Tropp, J. A. (2004). Greed 
% is Good: Algorithmic Results for Sparse  Approximation. IEEE Transactions on 
% Information Theory, 50(10),  2231–2242>.
% 
% 
% 
% *Note:* this livescript was executed using the following matfaust version:

matfaust.version()
##### SOURCE END #####
--></body></html>