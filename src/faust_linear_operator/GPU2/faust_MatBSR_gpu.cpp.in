#include "faust_MatBSR_gpu.h"
namespace Faust
{
	template<>
		MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::MatBSR(
				const faust_unsigned_int nrows,
				const faust_unsigned_int ncols,
				const faust_unsigned_int bnrows,
				const faust_unsigned_int bncols,
				const faust_unsigned_int bnnz,
				const @FAUST_SCALAR_FOR_GM@* bdata,
				const int32_t* browptr,
				const int32_t* bcolinds,
				const int32_t dev_id/*=-1*/,
				const void* stream/*=nullptr*/)
		{
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			auto gp_funcs = GPUModHandler::get_singleton()->gp_funcs();
			auto cur_dev_id = gp_funcs->cur_dev();
			gp_funcs->set_dev(dev_id);
			//TODO: gpu_stream
			//	gpu_mat = spm_funcs->togpu_stream();
			gpu_mat = bsr_funcs->togpu(nrows, ncols, bnrows, bncols,  (@GM_SCALAR@*) reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(bdata), browptr, bcolinds, bnnz);
			gp_funcs->set_dev(cur_dev_id);
		}

	template<>
		void MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>& M, char opThis/*='N'*/) const
		{
			gm_Op gop_this;
			char2gm_Op(opThis, gop_this);
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			auto gpu_dmat = bsr_funcs->mul_gpu_dsm_ext(gpu_mat, M.gpu_mat, nullptr, gop_this, OP_NOTRANSP);
			dsm_funcs->free(M.get_gpu_mat_ptr());
			M.gpu_mat = gpu_dmat;
		}

	template<>
		void MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(Vect<@FAUST_SCALAR_FOR_GM@,GPU2>& vec, char opThis/*='N'*/) const
		{
			gm_Op gop_this;
			char2gm_Op(opThis, gop_this);
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			// the backend code is specialized for vector (the number of columns is tested to call another function, see gpu_mod)
			auto gpu_dmat = bsr_funcs->mul_gpu_dsm_ext(gpu_mat, vec.gpu_mat, nullptr, gop_this, OP_NOTRANSP);
			dsm_funcs->free(vec.get_gpu_mat_ptr());
			vec.gpu_mat = gpu_dmat;
		}

	template<>
		void MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::tocpu(int32_t* browptr, int32_t* bcolinds, @FAUST_SCALAR_FOR_GM@* bdata, int32_t* nrows/*=nullptr*/, int32_t* ncols/*=nullptr*/, int32_t *bnrows/*=nullptr*/, int32_t *bncols/*=nullptr*/, int32_t* bnnz/*=nullptr*/) const
		{
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			bsr_funcs->tocpu(gpu_mat, browptr, bcolinds, (@GM_SCALAR@*) reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(bdata), nrows, ncols, bnrows, bncols, bnnz);
		}

	template<>
		void MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::tocpu(MatBSR<@FAUST_SCALAR_FOR_GM@, Cpu> &cpu_mat) const
		{
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			int32_t nrows, ncols, bnrows, bncols, bnnz;
			bsr_funcs->info(gpu_mat, &nrows, &ncols, &bnrows, &bncols, &bnnz);
			MatBSR<@FAUST_SCALAR_FOR_GM@, Cpu> M(nrows, ncols, bnrows, bncols, bnnz);
			bsr_funcs->tocpu(gpu_mat, const_cast<int*>(M.get_browptr()), const_cast<int*>(M.get_bcolinds()), (@GM_SCALAR@*) reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(const_cast<@FAUST_SCALAR_FOR_GM@*>(M.get_bdata())), nullptr, nullptr, nullptr, nullptr, nullptr);
			cpu_mat = std::move(M);
		}

	template<>
		MatSparse<@FAUST_SCALAR_FOR_GM@, GPU2> MatBSR<@FAUST_SCALAR_FOR_GM@,GPU2>::to_sparse() const
		{
			MatSparse<@FAUST_SCALAR_FOR_GM@, GPU2> spm;
			auto bsr_funcs = GPUModHandler::get_singleton()->bsr_funcs((@FAUST_SCALAR_FOR_GM@)(0));
			spm.set_gpu_mat_ptr(bsr_funcs->to_csr(gpu_mat));
			return spm;
		}
}

