#include "faust_Vect_gpu.h"
#ifndef _FSFG_
#define _FSFG_
typedef @FAUST_SCALAR_FOR_GM@ FSFG;
#endif
namespace Faust
{

	template<>
		Vect<FSFG,GPU2>::Vect():MatDense<FSFG,GPU2>()
	{
	}

	template<>
		Vect<FSFG,GPU2>::Vect(const faust_unsigned_int size,
				const FSFG* cpu_data,
				const bool no_alloc,
				const int32_t dev_id,
				const void* stream): MatDense<FSFG,GPU2>(size, 1, cpu_data, no_alloc, dev_id, stream)
	{
	}

	template<>
	faust_unsigned_int Vect<FSFG,GPU2>::size() const
	{
		return this->getNbRow();
	}

	template<>
		void Vect<FSFG,GPU2>::resize(const faust_unsigned_int size)
		{
			MatDense<FSFG, GPU2>::resize(size, 1);
		}

	template<>
		void Vect<FSFG,GPU2>::operator=(const Vect<FSFG,GPU2> & v)
		{
			if(size() == v.size())
				MatDense<FSFG, GPU2>::operator=(v);
			else
				throw std::runtime_error("Dimensions must agree.");
		}

	template<>
		void Vect<FSFG,GPU2>::operator=(const Vect<FSFG,Cpu> & v)
		{
			if(size() == v.size())
			{
				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
				auto gpu_mat = dsm_funcs->togpu(this->getNbRow(), 1, const_cast<@FAUST_SCALAR_FOR_GM@*>(v.getData()));
				dsm_funcs->free(this->gpu_mat);
				this->gpu_mat = gpu_mat;
			}
			else
				throw std::runtime_error("Dimensions must agree.");
		}

	template<>
		FSFG Vect<FSFG,GPU2>::max_coeff()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			FSFG _max_coeff;
			dsm_funcs->max(this->gpu_mat, &_max_coeff);
			return _max_coeff;
		}

		template<>
		FSFG Vect<FSFG,GPU2>::min_coeff()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			FSFG _min_coeff;
			dsm_funcs->min(this->gpu_mat, &_min_coeff);
			return _min_coeff;
		}

		template<>
		FSFG Vect<FSFG,GPU2>::dot(const Vect<FSFG,GPU2> &v)
		{
			FSFG alpha;
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			dsm_funcs->dot(this->gpu_mat, v.gpu_mat, &alpha);
			return alpha;
		}

		template<>
		FSFG Vect<FSFG,GPU2>::sum() const
		{
			FSFG s;
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			dsm_funcs->sum(this->gpu_mat, reinterpret_cast<@GM_REINTERPRET_CAST_SCALAR@*>(&s));
			return s;
		}

		template<>
			FSFG Vect<FSFG,GPU2>::mean() const
			{
				return sum()/size();
			}

		template<>
		void Vect<FSFG,GPU2>::multiplyLeft(MatSparse<FSFG,GPU2> const& S, const char transS)
		{

		}

		template<>
		void Vect<FSFG,GPU2>::operator*=(const Vect<FSFG,GPU2> &v)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			dsm_funcs->elt_wise_mul(this->gpu_mat, v.gpu_mat);
		}

		template<>
		void Vect<FSFG,GPU2>::operator/=(const Vect<FSFG,GPU2> &v)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
			dsm_funcs->elt_wise_div(this->gpu_mat, v.gpu_mat);
		}

		template<>
			bool Vect<FSFG,GPU2>::operator==(const Vect<FSFG,GPU2> &v) const
			{
				return this->get_gpu_mat_ptr() == v.get_gpu_mat_ptr();
			}

		template<>
			bool Vect<FSFG,GPU2>::operator!=(const Vect<FSFG,GPU2> &v) const
			{
				return ! (*this==v);
			}

		template<>
			Vect<FSFG,Cpu> Vect<FSFG,GPU2>::tocpu(const void* stream/*=nullptr*/) const
			{
				auto matvec = MatDense<FSFG,GPU2>::tocpu(stream);
				return Vect<FSFG, Cpu>(size(), matvec.getData());
			}

		template<>
			void Vect<FSFG,GPU2>::Display() const
			{
				Vect<FSFG, Cpu> v = tocpu();
				v.Display();
			}

		template<>
			void Vect<FSFG,GPU2>::setValues(const FSFG& val)
			{
				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
				dsm_funcs->setval(this->gpu_mat, reinterpret_cast<@GM_REINTERPRET_CAST_SCALAR@*>(const_cast<FSFG*>(&val)));
			}

		template<>
			FSFG Vect<FSFG,GPU2>::mean_relative_error(const Vect<FSFG,GPU2>& ref_vec) const
			{

				FSFG e;
				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
				dsm_funcs->mean_relerr(this->get_gpu_mat_ptr(), ref_vec.get_gpu_mat_ptr(), reinterpret_cast<@GM_REINTERPRET_CAST_SCALAR@*>(&e));
				return e;
			}

		template<>
			FSFG Vect<FSFG,GPU2>::operator[](faust_unsigned_int i)
			{
				FSFG coeff;
				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
				dsm_funcs->coeff(this->gpu_mat, i, 0, reinterpret_cast<@GM_REINTERPRET_CAST_SCALAR@*>(&coeff));
				return coeff;
			}


		template<>
			void Vect<FSFG,GPU2>::set_coeff(faust_unsigned_int i, const FSFG& val)
			{
				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(@FAUST_SCALAR_FOR_GM@(0));
				dsm_funcs->set_coeff(this->gpu_mat, i, 0, reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(&val));
			}
}
