//TODO: move to CPP
template<>
Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::MatDense(
		const faust_unsigned_int nbRow,
		const faust_unsigned_int nbCol,
		const @FAUST_SCALAR_FOR_GM@* data/*=nullptr*/,
		const bool no_alloc/*= false*/)
{
	this->dim1 = nbRow;
	this->dim2 = nbCol;
	FaustGPU<@FAUST_SCALAR_FOR_GM@>::load_gm_functions();
	if(this->dsm_funcs == nullptr)
		this->dsm_funcs = FaustGPU<@FAUST_SCALAR_FOR_GM@>::dsm_funcs;
	if(this->spm_funcs == nullptr)
		this->spm_funcs = FaustGPU<@FAUST_SCALAR_FOR_GM@>::spm_funcs;
	if(nullptr != data)
		gpu_mat = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs)->togpu(nbRow, nbCol, const_cast<@FAUST_SCALAR_FOR_GM@*>(data));
	else if(! no_alloc)
		gpu_mat = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs)->create(nbRow, nbCol);
}

template<>
Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::~MatDense()
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->free(gpu_mat);
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(MatDense<@FAUST_SCALAR_FOR_GM@, GPU2> &other, const char op_this)
{
	// other = this * other
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, other.gpu_mat, other.gpu_mat, OP_NOTRANSP, OP_NOTRANSP);
	//TODO: update dims (in transpose/adjoint case)
	other.dim1 = dim1;
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(MatDense<@FAUST_SCALAR_FOR_GM@, Cpu> &other, const char op_this)
{
	// other = this * other
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	MatDense<@FAUST_SCALAR_FOR_GM@, GPU2> other_gpu_mat(other.dim1, other.dim2,other.getData());
	dsm_funcs->mul_gpu_dsm_tocpu_ext(this->gpu_mat, other_gpu_mat.gpu_mat, other.getData(), OP_NOTRANSP, OP_NOTRANSP);
	//TODO: update dims (in transpose/adjoint case)
	other.dim1 = dim1;
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(const MatSparse<@FAUST_SCALAR_FOR_GM@, Cpu> &other, MatDense<@FAUST_SCALAR_FOR_GM@,Cpu>& output, const char op_this)
{
	auto spm_funcs = ((gm_SparseMatFunc_@GM_SCALAR@*) this->spm_funcs);
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	//togpu(int32_t nrows, int32_t ncols, int32_t nnz, int32_t* row_ptr, int32_t* col_inds, @GM_SCALAR@* values)
	auto other_gpu = spm_funcs->togpu(other.getNbRow(), other.getNbCol(), other.getNonZeros(), (int32_t*) other.getRowPtr(), (int32_t*) other.getColInd(), (double*) other.getValuePtr());
	// mul_gpu_spm_ext(gm_DenseMat_t, gm_SparseMat_t, gm_DenseMat_t output, gm_Op, gm_Op);
	auto output_gpu_mat = dsm_funcs->mul_gpu_spm_ext(gpu_mat, other_gpu, nullptr, OP_NOTRANSP, OP_NOTRANSP);
	output = MatDense<@FAUST_SCALAR_FOR_GM@, Cpu>(getNbRow(), other.getNbCol()); //TODO: manage transpose case
	dsm_funcs->tocpu(output_gpu_mat, output.getData());
	dsm_funcs->free(output_gpu_mat);
	spm_funcs->free(other_gpu);
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::multiply(const MatSparse<@FAUST_SCALAR_FOR_GM@, Cpu> &other, MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>& output, const char op_this)
{
	auto spm_funcs = ((gm_SparseMatFunc_@GM_SCALAR@*) this->spm_funcs);
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*) this->dsm_funcs);
	auto other_gpu = spm_funcs->togpu(other.getNbRow(), other.getNbCol(), other.getNonZeros(), (int32_t*) other.getRowPtr(), (int32_t*) other.getColInd(), (double*) other.getValuePtr());
	if(output.gpu_mat != nullptr)
		dsm_funcs->free(output.gpu_mat);
	output.gpu_mat = dsm_funcs->mul_gpu_spm_ext(gpu_mat, other_gpu, nullptr, OP_NOTRANSP, OP_NOTRANSP);
	spm_funcs->free(other_gpu);
}

template<>
Faust::MatDense<@FAUST_SCALAR_FOR_GM@, Cpu> Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::tocpu()
{
	MatDense<@FAUST_SCALAR_FOR_GM@, Cpu> cpu_mat(dim1, dim2);
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->tocpu(gpu_mat, cpu_mat.getData());
	return cpu_mat; //TODO: move constructor for MatDense<FPP, Cpu>
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::resize(const faust_unsigned_int nbRow, const faust_unsigned_int nbCol)
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->resize(gpu_mat, nbRow, nbCol);
	this->dim1 = nbRow;
	this->dim2 = nbCol;
	int32_t new_nrows, new_ncols;
	dsm_funcs->info(gpu_mat, &new_nrows, &new_ncols);
	assert(nbRow == new_nrows && new_ncols == nbCol);
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::setOnes()
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->setones(gpu_mat);
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::setZeros()
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->setzeros(gpu_mat);
}

template<>
void Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::setEyes()
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	dsm_funcs->seteyes(gpu_mat);
}

template<>
Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>* Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>::clone()
{
	auto dsm_funcs = ((gm_DenseMatFunc_@GM_SCALAR@*)this->dsm_funcs);
	auto gpu_mat = dsm_funcs->clone(this->gpu_mat);
	auto clone_mat = new Faust::MatDense<@FAUST_SCALAR_FOR_GM@,GPU2>(dim1, dim2, nullptr, /*no_alloc*/true);
	clone_mat->gpu_mat = gpu_mat;
	return clone_mat;
}
