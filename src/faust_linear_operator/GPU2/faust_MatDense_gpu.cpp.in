#ifndef _FSFG_
#define _FSFG_
typedef @FAUST_SCALAR_FOR_GM@ FSFG;
#endif
//TODO: move to cpp.in
#include "faust_MatDense_gpu.h"
namespace Faust
{
	template<>
		int32_t Faust::MatDense<FSFG, GPU2>::getNbRow() const
		{
			int32_t nrows;
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->info(gpu_mat, &nrows, nullptr);
			return nrows;
		}

	template<>
		int32_t Faust::MatDense<FSFG, GPU2>::getNbCol() const
		{
			int32_t ncols;
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->info(gpu_mat, nullptr, &ncols);
			return ncols;
		}

	template<>
		Faust::MatDense<FSFG,GPU2>::MatDense(
				const faust_unsigned_int nbRow,
				const faust_unsigned_int nbCol,
				const FSFG* data/*=nullptr*/,
				const bool no_alloc/*= false*/,
				const int32_t dev_id/*=-1*/,
				const void* stream/*=nullptr*/) : MatGeneric<FSFG,GPU2>()
	{
		auto gp_funcs = GPUModHandler::get_singleton()->gp_funcs();
		auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
		// create the matrix in the device dev_id memory
		auto cur_dev_id = gp_funcs->cur_dev();
		gp_funcs->set_dev(dev_id);
		if(nullptr != data)
			// use a stream to copy (if not nullptr)
			gpu_mat = dsm_funcs->togpu_stream(nbRow, nbCol, const_cast<FSFG*>(data), stream);
		else if(! no_alloc)
			gpu_mat = dsm_funcs->create(nbRow, nbCol);
		else
			gpu_mat = nullptr;
		gp_funcs->set_dev(cur_dev_id);
	}

	template<>
		MatDense<FSFG,GPU2>::~MatDense()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			if(gpu_mat != nullptr)
			{
				dsm_funcs->free(gpu_mat);
			}
		}

	template<>
		Faust::MatDense<FSFG,GPU2>::MatDense() : MatDense<FSFG,GPU2>(0,0,nullptr,true)
	{
	}



	template<>
		Faust::MatDense<FSFG,GPU2>::MatDense(
				const MatDense<FSFG,Cpu>& mat,
				const int32_t dev_id/*=-1*/,
				const void* stream/*=nullptr*/) : MatDense<FSFG,GPU2>(mat.getNbRow(), mat.getNbCol(), mat.getData(), /*no_alloc*/ mat.getData() == nullptr, dev_id, stream){}



	template<>
		void Faust::MatDense<FSFG,GPU2>::multiply(const MatDense<FSFG, GPU2> &other, const char op_this)
		{
			// other = this * other
			gm_Op gop_this;
			char2gm_Op(op_this, gop_this);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, other.gpu_mat, other.gpu_mat, gop_this, OP_NOTRANSP);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::multiply(MatDense<FSFG, Cpu> &other, const char op_this)
		{
			// other = this * other
			gm_Op gop_this;
			char2gm_Op(op_this, gop_this);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			MatDense<FSFG, GPU2> other_gpu_mat(other.getNbRow(), other.getNbCol(), other.getData());
			if(gop_this == OP_NOTRANSP)
				other.resize(this->getNbRow(), other.getNbCol());
			else
				other.resize(this->getNbCol(), other.getNbRow());
			dsm_funcs->mul_gpu_dsm_tocpu_ext(this->gpu_mat, other_gpu_mat.gpu_mat, other.getData(), gop_this, OP_NOTRANSP);
		}

	template<>
		Faust::Vect<FSFG,Cpu> Faust::MatDense<FSFG,GPU2>::multiply(const Faust::Vect<FSFG, Cpu> &vec)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			MatDense<FSFG, GPU2> gpu_vec(vec.size(), 1, vec.getData(), /* no_alloc */ false, /*dev_id=*/-1, /*stream=*/nullptr); // avoiding ambiguity for the ctor overload choice (gcc warning)
			Faust::Vect<FSFG, Cpu> out_v(getNbCol());
			dsm_funcs->mul_gpu_dsm_tocpu_ext(this->gpu_mat, gpu_vec.gpu_mat, out_v.getData(), OP_NOTRANSP, OP_NOTRANSP);
			return out_v;
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::multiply(const MatSparse<FSFG, Cpu> &other, MatDense<FSFG,Cpu>& output, const char op_this)
		{
			gm_Op gop_this;
			char2gm_Op(op_this, gop_this);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			auto spm_funcs = GPUModHandler::get_singleton()->spm_funcs(FSFG(0));
			//togpu(int32_t nrows, int32_t ncols, int32_t nnz, int32_t* row_ptr, int32_t* col_inds, @GM_SCALAR@* values)
			auto other_gpu = spm_funcs->togpu(other.getNbRow(), other.getNbCol(), other.getNonZeros(), (int32_t*) other.getRowPtr(), (int32_t*) other.getColInd(), (double*) other.getValuePtr());
			// mul_gpu_spm_ext(gm_DenseMat_t, gm_SparseMat_t, gm_DenseMat_t output, gm_Op, gm_Op);
			auto output_gpu_mat = dsm_funcs->mul_gpu_spm_ext(gpu_mat, other_gpu, nullptr, gop_this, OP_NOTRANSP);
			output = MatDense<FSFG, Cpu>(getNbRow(), other.getNbCol()); //TODO: manage transpose case
			dsm_funcs->tocpu(output_gpu_mat, output.getData());
			dsm_funcs->free(output_gpu_mat);
			spm_funcs->free(other_gpu);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::multiply(const MatSparse<FSFG, Cpu> &other, MatDense<FSFG,GPU2>& output, const char op_this)
		{
			gm_Op gop_this;
			char2gm_Op(op_this, gop_this);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			auto spm_funcs = GPUModHandler::get_singleton()->spm_funcs(FSFG(0));
			auto other_gpu = spm_funcs->togpu(other.getNbRow(), other.getNbCol(), other.getNonZeros(), (int32_t*) other.getRowPtr(), (int32_t*) other.getColInd(), (double*) other.getValuePtr());
			if(output.gpu_mat != nullptr)
				dsm_funcs->free(output.gpu_mat);
			output.gpu_mat = dsm_funcs->mul_gpu_spm_ext(gpu_mat, other_gpu, nullptr, gop_this, OP_NOTRANSP);
			spm_funcs->free(other_gpu);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::scalarMultiply(const FSFG& lambda)
		{

			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->mul_scalar(gpu_mat, &lambda);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::operator*=(const FSFG& lambda)
		{
			this->scalarMultiply(lambda);
		}

	template<>
		Real<FSFG> Faust::MatDense<FSFG,GPU2>::norm() const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			return dsm_funcs->norm_frob(gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::tocpu(FSFG* cpu_buffer, const void* stream/*=nullptr*/) const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->set_stream(gpu_mat, stream);
			dsm_funcs->tocpu(gpu_mat, cpu_buffer);
			dsm_funcs->set_stream(gpu_mat, nullptr);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::tocpu(MatDense<FSFG, Cpu>& cpu_mat, const void* stream/*=nullptr*/) const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			cpu_mat.resize(getNbRow(), getNbCol());
//			dsm_funcs->set_stream(gpu_mat, stream);
//			dsm_funcs->tocpu(gpu_mat, cpu_mat.getData());
//			dsm_funcs->set_stream(gpu_mat, nullptr);
			this->tocpu(cpu_mat.getData(), stream);
		}

	template<>
		Faust::MatDense<FSFG, Cpu> Faust::MatDense<FSFG,GPU2>::tocpu(const void* stream/*=nullptr*/) const
		{
			MatDense<FSFG, Cpu> cpu_mat(getNbRow(), getNbCol());
			this->tocpu(cpu_mat, stream);
			return cpu_mat; //TODO: move constructor for MatDense<FPP, Cpu>
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::resize(const faust_unsigned_int nbRow, const faust_unsigned_int nbCol)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			if(gpu_mat != nullptr)
				dsm_funcs->resize(gpu_mat, nbRow, nbCol);
			else
				gpu_mat = dsm_funcs->create(nbRow, nbCol);
#ifndef NDEBUG
			int32_t new_nrows, new_ncols;
			dsm_funcs->info(gpu_mat, &new_nrows, &new_ncols);
			assert(getNbRow() == new_nrows && new_ncols == getNbCol());
#endif
		}

	template<>
		Faust::MatDense<FSFG, GPU2>& Faust::MatDense<FSFG, GPU2>::operator=(const MatDense<FSFG, GPU2>& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			if(A.gpu_mat != nullptr)
			{
				resize(A.getNbRow(), A.getNbCol());
				dsm_funcs->copy(A.gpu_mat, this->gpu_mat);
			}
			else
			{
				dsm_funcs->free(gpu_mat);
				this->gpu_mat = nullptr;
			}
			return *this;
		}

	template<>
		Faust::MatDense<FSFG,GPU2>::MatDense(const MatSparse<FSFG,GPU2>& mat) : MatDense<FSFG,GPU2>()
		{
			if(mat.get_gpu_mat_ptr() != nullptr)
			{
				resize(mat.getNbRow(), mat.getNbCol());
				auto spm_funcs = GPUModHandler::get_singleton()->spm_funcs(FSFG(0));
				spm_funcs->copy2dense(mat.get_gpu_mat_ptr(), this->gpu_mat);
			}
		}

	template<>
	void Faust::MatDense<FSFG, GPU2>::operator=(const MatSparse<FSFG,GPU2> & A)
	{
		MatDense<FSFG,GPU2> dm(A);
		*this = dm;
	}

	template<>
		void Faust::MatDense<FSFG,GPU2>::setOnes()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->setones(gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::setZeros()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->setzeros(gpu_mat);
			this->is_zeros = true;
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::setEyes()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->seteyes(gpu_mat);
			this->is_identity = true;
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::move(const int32_t dev_id/*=-1*/, const void* stream/*=nullptr*/)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			//TODO: backup possible pre-existing stream to restore it afterward
			dsm_funcs->set_stream(gpu_mat, stream);
			dsm_funcs->mv_to_gpu(gpu_mat, dev_id);
			dsm_funcs->set_stream(gpu_mat, nullptr);
		}


	template<>
		Faust::MatDense<FSFG,GPU2>* Faust::MatDense<FSFG,GPU2>::clone(const int32_t dev_id/*=-1*/, const void* stream/*=nullptr*/) const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			auto gp_funcs = GPUModHandler::get_singleton()->gp_funcs();
			auto cur_dev_id = gp_funcs->cur_dev();
			// change to device where to create the clone
			gp_funcs->set_dev(dev_id);
			// use a stream (nullptr means default)
			dsm_funcs->set_stream(this->gpu_mat, stream);
			auto gpu_mat = dsm_funcs->clone(this->gpu_mat);
			auto clone_mat = new Faust::MatDense<FSFG,GPU2>(getNbRow(), getNbCol(), nullptr, /*no_alloc*/true, dev_id);
			clone_mat->gpu_mat = gpu_mat;
			// return to previous device
			gp_funcs->set_dev(cur_dev_id);
			// disable the stream
			dsm_funcs->set_stream(this->gpu_mat, nullptr);
			return clone_mat;
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::transpose()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->transpose(this->gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::adjoint()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->adjoint(this->gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::conjugate()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->conjugate(this->gpu_mat);
		}

	template<>
		Real<FSFG> Faust::MatDense<FSFG,GPU2>::spectralNorm(const faust_unsigned_int nbr_iter_max, const float threshold)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			return dsm_funcs->norm_spectral(gpu_mat, threshold, nbr_iter_max);
		}


	template<>
		void Faust::MatDense<FSFG,GPU2>::normalize()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->normalize(gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG,GPU2>::abs()
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->abs(gpu_mat);
		}

	template<>
		Real<FSFG> Faust::MatDense<FSFG,GPU2>::normL1() const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			return dsm_funcs->norm_l1(gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::add(MatDense<FSFG,GPU2> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->add_gpu_dsm(this->gpu_mat, A.gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::add(MatDense<FSFG,Cpu> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->add_cpu_dsm(gpu_mat, A.getData(), A.getNbRow(), A.getNbCol());
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::add(MatSparse<FSFG,Cpu> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->add_cpu_spm(this->gpu_mat, A.getNbRow(), A.getNbCol(), A.getNonZeros(), A.getRowPtr(), A.getColInd(), A.getValuePtr());
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator+=(MatSparse<FSFG,Cpu> const& A)
		{
			this->add(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator+=(MatDense<FSFG,Cpu> const& A)
		{
			this->add(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator+=(MatDense<FSFG,GPU2> const& A)
		{
			this->add(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::sub(MatDense<FSFG,GPU2> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->sub_gpu_dsm(this->gpu_mat, A.gpu_mat);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::sub(MatDense<FSFG,Cpu> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->sub_cpu_dsm(gpu_mat, const_cast<FSFG*>(A.getData()), A.getNbRow(), A.getNbCol());
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::sub(MatSparse<FSFG,Cpu> const& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->sub_cpu_spm(this->gpu_mat, A.getNbRow(), A.getNbCol(), A.getNonZeros(), A.getRowPtr(), A.getColInd(), A.getValuePtr());
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator-=(MatSparse<FSFG,Cpu> const& A)
		{
			this->sub(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator-=(MatDense<FSFG,Cpu> const& A)
		{
			this->sub(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator-=(MatDense<FSFG,GPU2> const& A)
		{
			this->sub(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::multiplyRight(const MatDense<FSFG,GPU2> & A)
		{
			// other = this * other
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, A.gpu_mat, this->gpu_mat, OP_NOTRANSP, OP_NOTRANSP);
			Faust::MatDense<FSFG,GPU2> new_this(getNbRow(), A.getNbCol(), nullptr, /* no_alloc */ false, /*dev_id=*/-1, /*stream=*/nullptr);
			dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, A.gpu_mat, new_this.gpu_mat, OP_NOTRANSP, OP_NOTRANSP);
			auto tmp = this->gpu_mat;
			this->gpu_mat = new_this.gpu_mat;
			new_this.gpu_mat = tmp;
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::multiplyRight(const MatDense<FSFG,Cpu> & A)
		{
			// this = this * other
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			MatDense<FSFG,GPU2> gpuA(A.getNbRow(), A.getNbCol(), A.getData());
			Faust::MatDense<FSFG,GPU2> new_this(getNbRow(), A.getNbCol(), nullptr);
			dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, gpuA.gpu_mat, new_this.gpu_mat, OP_NOTRANSP, OP_NOTRANSP);
			auto tmp = this->gpu_mat;
			this->gpu_mat = new_this.gpu_mat;
			new_this.gpu_mat = tmp;
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator*=(const MatDense<FSFG,GPU2> & A)
		{
			this->multiplyRight(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator*=(const MatDense<FSFG,Cpu> & A)
		{
			this->multiplyRight(A);
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::multiplyLeft(const MatSparse<FSFG,Cpu> & S, const char transS/*='N'*/)
		{
			auto spm_funcs = GPUModHandler::get_singleton()->spm_funcs(FSFG(0));
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			if(is_zeros)
			{
				resize(S.getNbRow(), getNbCol());
				setZeros();
			}
			else
			{
				auto gpu_S = spm_funcs->togpu(S.getNbRow(), S.getNbCol(), S.getNonZeros(), S.getRowPtr(), S.getColInd(), S.getValuePtr());

				auto gpu_out = spm_funcs->mul_gpu_dsm_ext(gpu_S, this->gpu_mat, nullptr, OP_NOTRANSP, OP_NOTRANSP);
				dsm_funcs->free(this->gpu_mat);
				spm_funcs->free(gpu_S);
				this->gpu_mat = gpu_out;
			}
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::operator=(const MatDense<FSFG, Cpu>& A)
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			auto gpu_mat = dsm_funcs->togpu(A.getNbRow(), A.getNbCol(), const_cast<FSFG*>(A.getData()));
			if(this->gpu_mat != nullptr)
				dsm_funcs->free(this->gpu_mat);
			this->gpu_mat = gpu_mat;
		}



	template<>
		void Faust::MatDense<FSFG, GPU2>::operator=(const MatSparse<FSFG, Cpu>& A)
		{
			MatDense<FSFG, Cpu> ds_A(A);
			*(this) = ds_A;
		}


	template<>
		MatDense<FSFG,GPU2>::MatDense(const MatDense<FSFG,GPU2>& mat) : MatDense<FSFG,GPU2>()
		{
			*this = mat;
		}

	template <>
		void gemm(const MatDense<FSFG, GPU2> &A, const MatDense<FSFG, GPU2> &B, MatDense<FSFG, GPU2> &C,
				const FSFG& alpha, const FSFG& beta, const char opA, const char opB)
		{
			gm_Op gop_A, gop_B;
			char2gm_Op(opA, gop_A);
			char2gm_Op(opB, gop_B);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->gemm(A.gpu_mat, B.gpu_mat, C.gpu_mat, reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(&alpha), reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(&beta), gop_A, gop_B);
		}

	template <>
		void gemv(const MatDense<FSFG, GPU2> &A, const Vect<FSFG, GPU2> &B, Vect<FSFG, GPU2> &C,
				const FSFG& alpha, const FSFG& beta, const char opA, const char opB/*='N'*/)
		{
			gm_Op gop_A, gop_B;
			char2gm_Op(opA, gop_A);
			char2gm_Op(opB, gop_B);
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->gemm(A.gpu_mat, B.gpu_mat, C.gpu_mat, reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(&alpha), reinterpret_cast<const @GM_REINTERPRET_CAST_SCALAR@*>(&beta), gop_A, gop_B);
		}

	template<>
		int32_t Faust::MatDense<FSFG, GPU2>::getDevice() const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			int32_t dev_id = dsm_funcs->get_dev(gpu_mat);
			return dev_id;
		}



	template<>
		std::string Faust::MatDense<FSFG, GPU2>::to_string(const bool transpose/*=false*/, const bool displaying_small_mat_elts/*=false*/) const
		{
			//TODO: rely on gpu_mod display function (yet to write)
			return "(on GPU device: " + std::to_string(getDevice())+ ") "+tocpu().to_string();
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::Display() const
		{
			std::cout << this->to_string();
		}

	template<>
		void* Faust::MatDense<FSFG, GPU2>::get_gpu_mat_ptr() const
		{
			return this->gpu_mat;
		}

	template<>
		void Faust::MatDense<FSFG, GPU2>::set_gpu_mat_ptr(void* gpu_mat)
		{
			this->gpu_mat = gpu_mat;
		}

	template<>
		faust_unsigned_int Faust::MatDense<FSFG, GPU2>::getNonZeros() const
		{
			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			if(gpu_mat != nullptr)
				return dsm_funcs->get_nnz(gpu_mat);
			throw std::runtime_error("gpu_mat is nullptr");
		}

	template<>
		void MatDense<FSFG,GPU2>::multiply(const Vect<FSFG, GPU2>& vec, Vect<FSFG, GPU2>& out_vec) const
		{

			auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
			dsm_funcs->mul_gpu_dsm_ext(this->gpu_mat, vec.get_gpu_mat_ptr(), out_vec.get_gpu_mat_ptr(), OP_NOTRANSP, OP_NOTRANSP);
		}

	template<>
		MatType MatDense<FSFG,GPU2>::getType() const
		{
			return Dense;
		}

	template<>
		MatDense<FSFG,GPU2>& MatDense<FSFG,GPU2>::operator=(MatDense<FSFG,GPU2>&& mat)
		{
			if(this->gpu_mat != nullptr)
			{

				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
				dsm_funcs->free(this->gpu_mat);
			}
			this->gpu_mat = mat.gpu_mat;
			mat.gpu_mat = nullptr;
			return *this;
		}

	template<>
		MatDense<FSFG,GPU2>::MatDense(MatDense<FSFG,GPU2>&& mat)
		{
			int32_t dev_id = 0;
			if(this->gpu_mat != nullptr)
			{

				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));
				dsm_funcs->free(this->gpu_mat);
			}
//			dev_id = mat.getDevice();
//			auto gp_funcs = GPUModHandler::get_singleton()->gp_funcs();
			this->gpu_mat = mat.gpu_mat;
			mat.gpu_mat = nullptr;
		}

	template<>
		FSFG MatDense<FSFG,GPU2>::trace() const
		{
			FSFG tr;
			if(this->gpu_mat != nullptr)
			{

				auto dsm_funcs = GPUModHandler::get_singleton()->dsm_funcs(FSFG(0));

				dsm_funcs->trace(this->gpu_mat, reinterpret_cast<@GM_REINTERPRET_CAST_SCALAR@*>(&tr));
				return tr;
			}
			throw std::runtime_error("gpu_mat is nullptr");
		}

	template<>
		MatDense<FSFG,GPU2>* MatDense<FSFG,GPU2>::get_rows(faust_unsigned_int start_row_id, faust_unsigned_int num_rows) const
		{
			//TODO: pure GPU impl.
			auto cpu_mat = tocpu();
			auto cpu_rows = cpu_mat.get_rows(start_row_id, num_rows);
			auto gpu_rows = new MatDense<FSFG,GPU2>(*cpu_rows);
			delete cpu_rows;
			return gpu_rows;
		}

	template<>
		MatDense<FSFG,GPU2>* MatDense<FSFG,GPU2>::get_rows(faust_unsigned_int* row_ids, faust_unsigned_int n) const
		{
			//TODO: pure GPU impl.
			auto cpu_mat = tocpu();
			auto cpu_rows = cpu_mat.get_rows(row_ids, n);
			auto gpu_rows = new MatDense<FSFG,GPU2>(*cpu_rows);
			delete cpu_rows;
			return gpu_rows;
		}

	template<>
		MatDense<FSFG,GPU2>* MatDense<FSFG,GPU2>::get_cols(faust_unsigned_int start_col_id, faust_unsigned_int num_cols) const
		{
			//TODO: pure GPU impl.
			auto cpu_mat = tocpu();
			auto cpu_cols = cpu_mat.get_cols(start_col_id, num_cols);
			auto gpu_cols = new MatDense<FSFG,GPU2>(*cpu_cols);
			delete cpu_cols;
			return gpu_cols;
		}

	template<>
		MatDense<FSFG,GPU2>* MatDense<FSFG,GPU2>::get_cols(faust_unsigned_int* col_ids, faust_unsigned_int n) const
		{
			//TODO: pure GPU impl.
			auto cpu_mat = tocpu();
			auto cpu_cols = cpu_mat.get_cols(col_ids, n);
			auto gpu_cols = new MatDense<FSFG,GPU2>(*cpu_cols);
			delete cpu_cols;
			return gpu_cols;
		}

	template<>
		MatGeneric<FSFG,GPU2>* MatDense<FSFG,GPU2>::Clone(const bool isOptimize /*default value = false*/) const
		{
			if (isOptimize)
			{
				MatSparse<FSFG,GPU2> S((*this));
				return optimize((*this),S);
			}
			else
			{
				return new MatDense<FSFG,GPU2>((*this));
			}
		}

};
