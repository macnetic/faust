/****************************************************************************/
/*                              Description:                                */
/*  For more information on the FAuST Project, please visit the website     */
/*  of the project : <http://faust.inria.fr>                         */
/*                                                                          */
/*                              License:                                    */
/*  Copyright (2019):    Hakim Hadj-Djilani, Nicolas Bellot, Adrien Leman, Thomas Gautrais,      */
/*                      Luc Le Magoarou, Remi Gribonval                     */
/*                      INRIA Rennes, FRANCE                                */
/*                      http://www.inria.fr/                                */
/*                                                                          */
/*  The FAuST Toolbox is distributed under the terms of the GNU Affero      */
/*  General Public License.                                                 */
/*  This program is free software: you can redistribute it and/or modify    */
/*  it under the terms of the GNU Affero General Public License as          */
/*  published by the Free Software Foundation.                              */
/*                                                                          */
/*  This program is distributed in the hope that it will be useful, but     */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                    */
/*  See the GNU Affero General Public License for more details.             */
/*                                                                          */
/*  You should have received a copy of the GNU Affero General Public        */
/*  License along with this program.                                        */
/*  If not, see <http://www.gnu.org/licenses/>.                             */
/*                                                                          */
/*                             Contacts:                                    */
/*      Hakim H. hakim.hadj-djilani@inria.fr                                */
/*      Nicolas Bellot  : nicolas.bellot@inria.fr                           */
/*      Adrien Leman    : adrien.leman@inria.fr                             */
/*      Thomas Gautrais : thomas.gautrais@inria.fr                          */
/*      Luc Le Magoarou : luc.le-magoarou@inria.fr                          */
/*      Remi Gribonval  : remi.gribonval@inria.fr                           */
/*                                                                          */
/*                              References:                                 */
/*  [1] Le Magoarou L. and Gribonval R., "Flexible multi-layer sparse       */
/*  approximations of matrices and applications", Journal of Selected       */
/*  Topics in Signal Processing, 2016.                                      */
/*  <https://hal.archives-ouvertes.fr/hal-01167948v1>                       */
/****************************************************************************/

// 
template void kernel_add<float>(float* d_cu1, const float* d_cu2, int length);
template void kernel_sub<float>(float* d_cu1, const float* d_cu2, int length);
template void kernel_mult<float>(float* d_cu1, const float* d_cu2, int length);
template void kernel_div<float>(float* d_cu1, const float* d_cu2, int length);
template void kernel_add_const<float>(float* d_cu1, float valeur, int length);
template void kernel_sub_const<float>(float* d_cu1, float valeur, int length);
template void kernel_mult_const<float>(float* d_cu1, float valeur, int length);
template void kernel_div_const<float>(float* d_cu1, float valeur, int length);
template void kernel_square<float>(float* d_cu1, int length);
template void kernel_square<float>(float* d_cu_dst, const float* d_cu_src, int length);
template void kernel_sqrt<float>(float* d_cu1, int length);
template void kernel_inv<float>(float* d_cu1, int length);
template void kernel_abs<float>(float* d_cu1, const int length);
template void kernel_memcpy<float,float>(float* d_cu_dst, const float* d_cu_src, int length);
template void kernel_memset<float>(float* d_cu_dst, float valeur, int length);
template void kernel_sparse2full<float>(float* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const float* dev_src_values, const int nnz, const int src_dim1, const int src_dim2);
template void kernel_add_sparse2full<float>(float* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const float* dev_src_values, const int nnz, const int src_dim1);
template void kernel_sub_sparse2full<float>(float* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const float* dev_src_values, const int nnz, const int src_dim1);
template void kernel_get_diag<float>(float* dst_diag, const float* src_M, int dim1);
template void kernel_add_diag_const<float>(float* d_cu1, float val, int dim1);
template void kernel_copy_diag<float>(float* d_cu_dst, float* d_cu_src, int dim1);
template void kernel_set_submatrix<float>(float* mat_dst, float* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_col);
template void kernel_relative_error<float>(float* data_dst, const float* data_src_th, const float* data_src_mes, const int length);

template void kernel_add<double>(double* d_cu1, const double* d_cu2, int length);
template void kernel_sub<double>(double* d_cu1, const double* d_cu2, int length);
template void kernel_mult<double>(double* d_cu1, const double* d_cu2, int length);
template void kernel_div<double>(double* d_cu1, const double* d_cu2, int length);
template void kernel_add_const<double>(double* d_cu1, double valeur, int length);
template void kernel_sub_const<double>(double* d_cu1, double valeur, int length);
template void kernel_mult_const<double>(double* d_cu1, double valeur, int length);
template void kernel_div_const<double>(double* d_cu1, double valeur, int length);
template void kernel_square<double>(double* d_cu1, int length);
template void kernel_square<double>(double* d_cu_dst, const double* d_cu_src, int length);
template void kernel_sqrt<double>(double* d_cu1, int length);
template void kernel_inv<double>(double* d_cu1, int length);
template void kernel_abs<double>(double* d_cu1, const int length);
template void kernel_memcpy<double,double>(double* d_cu_dst, const double* d_cu_src, int length);
template void kernel_memset<double>(double* d_cu_dst, double valeur, int length);
template void kernel_sparse2full<double>(double* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const double* dev_src_values, const int nnz, const int src_dim1, const int src_dim2);
template void kernel_add_sparse2full<double>(double* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const double* dev_src_values, const int nnz, const int src_dim1);
template void kernel_sub_sparse2full<double>(double* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const double* dev_src_values, const int nnz, const int src_dim1);
template void kernel_get_diag<double>(double* dst_diag, const double* src_M, int dim1);
template void kernel_add_diag_const<double>(double* d_cu1, double val, int dim1);
template void kernel_copy_diag<double>(double* d_cu_dst, double* d_cu_src, int dim1);
template void kernel_set_submatrix<double>(double* mat_dst, double* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_col);
template void kernel_relative_error<double>(double* data_dst, const double* data_src_th, const double* data_src_mes, const int length);

template void kernel_add<int>(int* d_cu1, const int* d_cu2, int length);
template void kernel_sub<int>(int* d_cu1, const int* d_cu2, int length);
template void kernel_mult<int>(int* d_cu1, const int* d_cu2, int length);
template void kernel_add_const<int>(int* d_cu1, int valeur, int length);
template void kernel_sub_const<int>(int* d_cu1, int valeur, int length);
template void kernel_mult_const<int>(int* d_cu1, int valeur, int length);
template void kernel_memcpy<int,int>(int* d_cu_dst, const int* d_cu_src, int length);
template void kernel_memset<int>(int* d_cu_dst, int valeur, int length);
template void kernel_sparse2full<int>(int* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const int* dev_src_values, const int nnz, const int src_dim1, const int src_dim2);
template void kernel_add_sparse2full<int>(int* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const int* dev_src_values, const int nnz, const int src_dim1);
template void kernel_sub_sparse2full<int>(int* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const int* dev_src_values, const int nnz, const int src_dim1);
template void kernel_get_diag<int>(int* dst_diag, const int* src_M, int dim1);
template void kernel_add_diag_const<int>(int* d_cu1, int val, int dim1);
template void kernel_copy_diag<int>(int* d_cu_dst, int* d_cu_src, int dim1);
template void kernel_set_submatrix<int>(int* mat_dst, int* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_col);

template void kernel_memcpy<double,float>(double* d_cu_dst, const float* d_cu_src, int length);
template void kernel_memcpy<float,double>(float* d_cu_dst, const double* d_cu_src, int length);






template __global__ void Add_inria<float>(float* A, const float *B, int numElements);
template __global__ void Sub_inria<float>(float* A, const float *B, int numElements);
template __global__ void Mult_inria<float>(float* A, const float *B, int numElements);
template __global__ void Div_inria<float>(float* A, const float *B, int numElements);
template __global__ void AddConst_inria<float>(float* A, float val, int numElements);
template __global__ void SubConst_inria<float>(float* A, float val, int numElements);
template __global__ void MultConst_inria<float>(float* A, float val, int numElements);
template __global__ void DivConst_inria<float>(float* A, float val, int numElements);
template __global__ void Sqrt_inria<float>(float* A, int numElements);
template __global__ void Inv_inria<float>(float* A, int numElements);
template __global__ void Abs_inria<float>(float* A, int numElements);
template __global__ void Memcpy_inria<float,float>(float* d_cu_dst, const float* d_cu_src, int length);
template __global__ void Memset_inria<float>(float* dev_dst, float valeur, int numElements);
template __global__ void Sparse2full_inria<float>(float* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const float* dev_src_values, const int nnz, const int src_dim1);
template __global__ void AddDiagConst_inria<float>(float* dev_dst, float val, int dim1);
template __global__ void GetDiag_inria<float>(float* dst_diag, const float* src_M,  int dim1);
template __global__ void SetSubmatrix_inria<float>(float* mat_dst, float* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_elements);
template __global__ void RelativeError_inria<float>(float* data_dst, const float* data_src_th, const float* data_src_mes, const int length);

template __global__ void Add_inria<double>(double* A, const double *B, int numElements);
template __global__ void Sub_inria<double>(double* A, const double *B, int numElements);
template __global__ void Mult_inria<double>(double* A, const double *B, int numElements);
template __global__ void Div_inria<double>(double* A, const double *B, int numElements);
template __global__ void AddConst_inria<double>(double* A, double val, int numElements);
template __global__ void SubConst_inria<double>(double* A, double val, int numElements);
template __global__ void MultConst_inria<double>(double* A, double val, int numElements);
template __global__ void DivConst_inria<double>(double* A, double val, int numElements);
template __global__ void Sqrt_inria<double>(double* A, int numElements);
template __global__ void Inv_inria<double>(double* A, int numElements);
template __global__ void Abs_inria<double>(double* A, int numElements);
template __global__ void Memcpy_inria<double,double>(double* d_cu_dst, const double* d_cu_src, int length);
template __global__ void Memset_inria<double>(double* dev_dst, double valeur, int numElements);
template __global__ void Sparse2full_inria<double>(double* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const double* dev_src_values, const int nnz, const int src_dim1);
template __global__ void AddDiagConst_inria<double>(double* dev_dst, double val, int dim1);
template __global__ void GetDiag_inria<double>(double* dst_diag, const double* src_M,  int dim1);
template __global__ void SetSubmatrix_inria<double>(double* mat_dst, double* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_elements);
template __global__ void RelativeError_inria<double>(double* data_dst, const double* data_src_th, const double* data_src_mes, const int length);

template __global__ void Add_inria<int>(int* A, const int *B, int numElements);
template __global__ void Sub_inria<int>(int* A, const int *B, int numElements);
template __global__ void Mult_inria<int>(int* A, const int *B, int numElements);
template __global__ void AddConst_inria<int>(int* A, int val, int numElements);
template __global__ void SubConst_inria<int>(int* A, int val, int numElements);
template __global__ void MultConst_inria<int>(int* A, int val, int numElements);
template __global__ void Memcpy_inria<int,int>(int* d_cu_dst, const int* d_cu_src, int length);
template __global__ void Memset_inria<int>(int* dev_dst, int valeur, int numElements);
template __global__ void Sparse2full_inria<int>(int* dev_dst, const int *dev_src_rowind, const int *dev_src_colind, const int* dev_src_values, const int nnz, const int src_dim1);
template __global__ void AddDiagConst_inria<int>(int* dev_dst, int val, int dim1);
template __global__ void GetDiag_inria<int>(int* dst_diag, const int* src_M,  int dim1);
template __global__ void SetSubmatrix_inria<int>(int* mat_dst, int* mat_src, int src_dim1, int r1, int c1, int nb_rows, int nb_elements);

template __global__ void Memcpy_inria<float,double>(float* d_cu_dst, const double* d_cu_src, int length);
template __global__ void Memcpy_inria<double,float>(double* d_cu_dst, const float* d_cu_src, int length);

