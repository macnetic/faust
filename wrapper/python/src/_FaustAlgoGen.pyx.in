# The code below is generic through cmake variables:
# TYPE_NAME can be Cplx or Real
# TYPE can be double or complex,
# CORE_CLASS can be FaustCore or FaustCoreCplx
# CORE_OBJ can be core_faust_cplx or core_faust_dbl

cdef class FaustAlgoGen@TYPE_NAME@:

    @staticmethod
    def fact_palm4msa_fft(Lap, p):
        return FaustAlgoGen@TYPE_NAME@.fact_palm4msa_gen(Lap, p, p.init_D)

    @staticmethod
    def fact_palm4msa(M, p):
        return FaustAlgoGen@TYPE_NAME@.fact_palm4msa_gen(M,p)

    @staticmethod
    def fact_palm4msa_gen(M, p, init_D=None):
        # M is supposed to be already verified (np.float or np.complex, fortran
        # contiguous, 1 or 2 dimensions)

        cdef unsigned int M_num_rows=M.shape[0]
        cdef unsigned int M_num_cols=M.shape[1]

        cdef @TYPE@[:,:] Mview

        cdef @TYPE@[:,:] tmp_mat

        # views for lambda and optionally D out buffer (FGFT)
        cdef @TYPE@[:] outbufview

        # only for FGFT
        cdef @TYPE@[:] init_D_view

        cdef FaustCoreCy.PyxParamsFactPalm4MSA[@TYPE@,double]* cpp_params

        # template parameter is always double (never complex) because no need
        # a threshold error of complex type
        cdef PyxStoppingCriterion[double] cpp_stop_crit
        cdef PyxConstraintGeneric** cpp_constraints


        cpp_stop_crit.is_criterion_error = p.stop_crit._is_criterion_error
        cpp_stop_crit.error_threshold = p.stop_crit.tol
        cpp_stop_crit.num_its = p.stop_crit.num_its
        cpp_stop_crit.max_num_its = p.stop_crit.maxiter

        calling_fft_algo = isinstance(init_D, np.ndarray)

        if(not p.init_facts):
            p.init_facts = [ None for i in range(p.num_facts) ]
            if(p.is_update_way_R2L):
                zeros_id = p.num_facts-1
            else:
                zeros_id = 0
            p.init_facts[zeros_id] = \
                np.zeros([p.constraints[zeros_id]._num_rows,p.constraints[zeros_id]._num_cols],
                        order='F', dtype=M.dtype)
            for i in [i for i in range(0, p.num_facts) if i != zeros_id]:
                p.init_facts[i] = np.eye(p.constraints[i]._num_rows,
                                        p.constraints[i]._num_cols, order='F',
                                        dtype=M.dtype)

        if(calling_fft_algo):
            # FFT/FGFT case, we store lambda in first position and the diagonal
            # of D in the next
            _out_buf = np.empty(init_D.shape[0]+1, dtype=M.dtype)
        else:
            # store only lambda as a return from Palm4MSA algo
            _out_buf = np.array([0], dtype=M.dtype)

        if(calling_fft_algo):
            cpp_params = new \
            FaustCoreCy.PyxParamsFactPalm4MSAFFT[@TYPE@,double]()
            init_D_view = init_D
            (<FaustCoreCy.PyxParamsFactPalm4MSAFFT[@TYPE@,double]*>cpp_params).init_D = &init_D_view[0]
        else:
            cpp_params = new \
            FaustCoreCy.PyxParamsFactPalm4MSA[@TYPE@,double]()
        Mview=M
        cpp_params.num_facts = p.num_facts
        cpp_params.is_update_way_R2L = p.is_update_way_R2L
        cpp_params.init_lambda = p.init_lambda
        cpp_params.step_size = p.step_size
        cpp_params.grad_calc_opt_mode = p.grad_calc_opt_mode
        cpp_params.norm2_max_iter = int(p.norm2_max_iter)
        cpp_params.norm2_threshold = p.norm2_threshold
        cpp_params.stop_crit = cpp_stop_crit
        cpp_params.init_facts = <@TYPE@**> \
                PyMem_Malloc(sizeof(@TYPE@*)*p.num_facts)
        cpp_params.init_fact_sizes = <unsigned long*> \
        PyMem_Malloc(sizeof(unsigned long)*2*p.num_facts)
        cpp_params.is_verbose = p.is_verbose
        cpp_params.constant_step_size = p.constant_step_size
        outbufview = _out_buf

        cpp_constraints = \
        <PyxConstraintGeneric**> \
        PyMem_Malloc(sizeof(PyxConstraintGeneric*)*len(p.constraints))

        for i in range(0,len(p.constraints)):
            cons = p.constraints[i]
            if(cons.is_int_constraint()):
                cpp_constraints[i] = <PyxConstraintInt*> PyMem_Malloc(sizeof(PyxConstraintInt))
                (<PyxConstraintInt*>cpp_constraints[i]).parameter = cons._cons_value
            elif(cons.is_real_constraint()):
                cpp_constraints[i] = <PyxConstraintScalar[double]*> \
                PyMem_Malloc(sizeof(PyxConstraintScalar[double]))
                (<PyxConstraintScalar[double]*>cpp_constraints[i]).parameter =\
                        cons._cons_value
            elif(cons.is_mat_constraint()):
                cpp_constraints[i] = <PyxConstraintMat[@TYPE@]*> \
                        PyMem_Malloc(sizeof(PyxConstraintMat[@TYPE@]))
                if cons._cons_value is not None: # eg. proj_id has no _cons_value
                    cons._cons_value = cons._cons_value.astype(type2dtype('@TYPE@'))
                    tmp_mat = cons._cons_value
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter =\
                            &tmp_mat[0,0]
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            cons._cons_value_sz
                else:
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            0
            else:
                raise ValueError("Constraint type/name is not recognized.")
            cpp_constraints[i].name = cons.name
            cpp_constraints[i].num_rows = cons._num_rows
            cpp_constraints[i].num_cols = cons._num_cols
            cpp_constraints[i].normalizing = cons.normalized
            cpp_constraints[i].pos = cons.pos


        cpp_params.constraints = cpp_constraints
        cpp_params.num_constraints = len(p.constraints)

        for i in range(0,p.num_facts):
            check_matrix('@TYPE@' == '@REAL_TYPE@', p.init_facts[i], message="while checking"
                         " palm4msa init facts: ")
            tmp_mat = p.init_facts[i]
            cpp_params.init_facts[i] = &tmp_mat[0,0]
            cpp_params.init_fact_sizes[i*2+0] = p.init_facts[i].shape[0]
            cpp_params.init_fact_sizes[i*2+1] = p.init_facts[i].shape[1]

        core = @CORE_CLASS@(core=True)

        if(calling_fft_algo):
            core.@CORE_OBJ@ = \
            FaustCoreCy.fact_palm4MSAFFT[@TYPE@,double](&Mview[0,0],
                                                        M_num_rows,
                                                        M_num_cols,
                                                        <FaustCoreCy.PyxParamsFactPalm4MSAFFT[@TYPE@,double]*>cpp_params,
                                                       &outbufview[0])
        else:
            core.@CORE_OBJ@ = FaustCoreCy.fact_palm4MSA[@TYPE@,double](&Mview[0,0], M_num_rows, M_num_cols,
#           FaustCoreCy.fact_palm4MSA(&Mview[0,0], M_num_rows, M_num_cols,
                                  cpp_params, &outbufview[0])

        for i in range(0,len(p.constraints)):
            PyMem_Free(cpp_constraints[i])
        PyMem_Free(cpp_constraints)

        PyMem_Free(cpp_params.init_facts)
        PyMem_Free(cpp_params.init_fact_sizes)

        del cpp_params

        if(calling_fft_algo):
            return core, np.real(_out_buf[0]), _out_buf[1:]
        else:
            return core, np.real(_out_buf[0])

    @staticmethod
    def fact_hierarchical_fft(U, Lap, p, init_D):
        return FaustAlgoGen@TYPE_NAME@.fact_hierarchical_gen(U, p, init_D, Lap)

    @staticmethod
    def fact_hierarchical(M, p):
        return FaustAlgoGen@TYPE_NAME@.fact_hierarchical_gen(M, p)

    @staticmethod
    def fact_hierarchical_gen(M, p, init_D=None, Lap=None):

        cdef unsigned int M_num_rows=M.shape[0]
        cdef unsigned int M_num_cols=M.shape[1]

        cdef @TYPE@[:,:] Mview

        cdef @TYPE@[:,:] Lapview

        # view for lambda and optionally D out buffer (FGFT)
        cdef @TYPE@[:] outbufview

        # only for FGFT
        cdef @TYPE@[:] init_D_view

        cdef @TYPE@[:,:] tmp_mat

        cdef FaustCoreCy.PyxParamsHierarchicalFact[@TYPE@,double]* cpp_params
        cdef PyxStoppingCriterion[double]* cpp_stop_crits
        # template parameter is always double (never complex) because no need
        # to have a threshold error of complex type (it wouldn't make sense)
        cdef PyxConstraintGeneric** cpp_constraints

        cpp_stop_crits = <PyxStoppingCriterion[double]*>\
        PyMem_Malloc(sizeof(PyxStoppingCriterion[double])*2)

        cpp_stop_crits[0].is_criterion_error = p.stop_crits[0]._is_criterion_error
        cpp_stop_crits[0].error_threshold = p.stop_crits[0].tol
        cpp_stop_crits[0].num_its = p.stop_crits[0].num_its
        cpp_stop_crits[0].max_num_its = p.stop_crits[0].maxiter
        cpp_stop_crits[1].is_criterion_error = p.stop_crits[1]._is_criterion_error
        cpp_stop_crits[1].error_threshold = p.stop_crits[1].tol
        cpp_stop_crits[1].num_its = p.stop_crits[1].num_its
        cpp_stop_crits[1].max_num_its = p.stop_crits[1].maxiter


        calling_fft_algo = isinstance(init_D, np.ndarray)

        if(calling_fft_algo):
            # FFT/FGFT case, we store lambda in first position and the diagonal
            # of D in the next
            _out_buf = np.empty(init_D.shape[0]+1, dtype=M.dtype)
        else:
            # store only lambda as a return from Palm4MSA algo
            _out_buf = np.array([0], dtype=M.dtype)

        if(calling_fft_algo):
            cpp_params = new \
            FaustCoreCy.PyxParamsHierarchicalFactFFT[@TYPE@,double]()
            init_D_view = init_D
            Lapview = Lap
            (<FaustCoreCy.PyxParamsHierarchicalFactFFT[@TYPE@,double]*>cpp_params).init_D = &init_D_view[0]
        else:
            cpp_params = new \
            FaustCoreCy.PyxParamsHierarchicalFact[@TYPE@,double]()
        Mview=M
        cpp_params.num_facts = p.num_facts
        cpp_params.num_facts = p.num_facts
        cpp_params.is_update_way_R2L = p.is_update_way_R2L
        cpp_params.init_lambda = p.init_lambda
        cpp_params.step_size = p.step_size
        cpp_params.grad_calc_opt_mode = p.grad_calc_opt_mode
        cpp_params.norm2_max_iter = int(p.norm2_max_iter)
        cpp_params.norm2_threshold =  p.norm2_threshold
        cpp_params.stop_crits = cpp_stop_crits
        cpp_params.is_verbose = p.is_verbose
        cpp_params.is_fact_side_left = p.is_fact_side_left
        cpp_params.constant_step_size = p.constant_step_size
        outbufview = _out_buf

        cpp_constraints = \
        <PyxConstraintGeneric**> \
        PyMem_Malloc(sizeof(PyxConstraintGeneric*)*len(p.constraints))

        for i in range(0,len(p.constraints)):
            cons = p.constraints[i]
            if(cons.is_int_constraint()):
                cpp_constraints[i] = <PyxConstraintInt*> PyMem_Malloc(sizeof(PyxConstraintInt))
                (<PyxConstraintInt*>cpp_constraints[i]).parameter = cons._cons_value
            elif(cons.is_real_constraint()):
                cpp_constraints[i] = <PyxConstraintScalar[double]*> \
                PyMem_Malloc(sizeof(PyxConstraintScalar[double]))
                (<PyxConstraintScalar[double]*>cpp_constraints[i]).parameter =\
                        cons._cons_value
            elif(cons.is_mat_constraint()):
                cpp_constraints[i] = <PyxConstraintMat[@TYPE@]*> \
                        PyMem_Malloc(sizeof(PyxConstraintMat[@TYPE@]))
                if cons._cons_value is not None: # eg. proj_id has no _cons_value
                    cons._cons_value = cons._cons_value.astype(type2dtype('@TYPE@'))
                    tmp_mat = cons._cons_value
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter =\
                            &tmp_mat[0,0]
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            cons._cons_value_sz
                else:
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            0
            else:
                raise ValueError("Constraint type/name is not recognized.")
            cpp_constraints[i].name = cons.name
            cpp_constraints[i].num_rows = cons._num_rows
            cpp_constraints[i].num_cols = cons._num_cols
            cpp_constraints[i].normalizing = cons.normalized
            cpp_constraints[i].pos = cons.pos

        cpp_params.constraints = cpp_constraints
        cpp_params.num_rows = p.data_num_rows
        cpp_params.num_cols = p.data_num_cols
        cpp_params.num_constraints = len(p.constraints)

        core = @CORE_CLASS@(core=True)
        if(calling_fft_algo):
            core.@CORE_OBJ@ = \
                    FaustCoreCy.fact_hierarchical_fft[@TYPE@,
                                                      double](&Mview[0,0],
                                                              &Lapview[0,0], M_num_rows, M_num_cols,
                                                              <FaustCoreCy.PyxParamsHierarchicalFactFFT[@TYPE@,double]*>cpp_params,
                                                              &outbufview[0])
        else:
            core.@CORE_OBJ@ = \
                    FaustCoreCy.fact_hierarchical[@TYPE@,
                                                  double](&Mview[0,0], M_num_rows, M_num_cols,
                                                          cpp_params, &outbufview[0])
        for i in range(0,len(p.constraints)):
            PyMem_Free(cpp_constraints[i])
        PyMem_Free(cpp_constraints)

        PyMem_Free(cpp_stop_crits)

        del cpp_params
        if(core.@CORE_OBJ@ == NULL): raise Exception("fact_hierarchical"
                                                          " has failed.");

        if(calling_fft_algo):
            return core, np.real(_out_buf[0]), _out_buf[1:]
        else:
            return core, np.real(_out_buf[0])

    @staticmethod
    def palm4msa2020(M, p, full_gpu=True):
        cdef unsigned int M_num_rows=M.shape[0]
        cdef unsigned int M_num_cols=M.shape[1]

        cdef @TYPE@[:,:] Mview
        cdef @TYPE@[:,:] tmp_mat
        # view for lambda
        cdef @REAL_TYPE@[:] outbufview

        cdef PyxStoppingCriterion[@REAL_TYPE@] cpp_stop_crit
        cdef PyxMHTPParams[@REAL_TYPE@] cpp_MHTPParams
        # template parameter is always double (never complex) because no need
        # to have a threshold error of complex type (it wouldn't make sense)
        cdef PyxConstraintGeneric** cpp_constraints

        cdef FaustCoreCy.@CPP_CORE_CLASS@[@TYPE@]* core_faust_init_facts

        Mview = M
        _out_buf = np.array([0], dtype=type2dtype('@REAL_TYPE@'))
        _out_buf[0] = p.init_lambda;
        outbufview = _out_buf

        cpp_stop_crit.is_criterion_error = p.stop_crit._is_criterion_error
        cpp_stop_crit.error_threshold = p.stop_crit.tol
        cpp_stop_crit.num_its = p.stop_crit.num_its
        cpp_stop_crit.max_num_its = p.stop_crit.maxiter

        # use_MHTP is either False or a MHTPParams instance
        if p.use_MHTP != False:
            mhtpp = p.use_MHTP
            cpp_MHTPParams.used = True
            cpp_MHTPParams.stop_crit.is_criterion_error = mhtpp.stop_crit._is_criterion_error
            cpp_MHTPParams.stop_crit.error_threshold = mhtpp.stop_crit.tol
            cpp_MHTPParams.stop_crit.num_its = mhtpp.stop_crit.num_its
            cpp_MHTPParams.stop_crit.max_num_its = mhtpp.stop_crit.maxiter
            cpp_MHTPParams.constant_step_size = mhtpp.constant_step_size
            cpp_MHTPParams.step_size = mhtpp.step_size
            cpp_MHTPParams.updating_lambda = mhtpp.updating_lambda
            cpp_MHTPParams.palm4msa_period = mhtpp.palm4msa_period
        else:
            cpp_MHTPParams.used = False

        cpp_constraints = \
        <PyxConstraintGeneric**> \
        PyMem_Malloc(sizeof(PyxConstraintGeneric*)*len(p.constraints))

        p.factor_format = \
        pyfaust.factparams.ParamsFact.factor_format_str2int(p.factor_format)

        for i in range(0,len(p.constraints)):
            cons = p.constraints[i]
            if cons.is_int_constraint():
                cpp_constraints[i] = <PyxConstraintInt*> PyMem_Malloc(sizeof(PyxConstraintInt))
                (<PyxConstraintInt*>cpp_constraints[i]).parameter = cons._cons_value
            elif cons.is_real_constraint():
                cpp_constraints[i] = <PyxConstraintScalar[@REAL_TYPE@]*> \
                PyMem_Malloc(sizeof(PyxConstraintScalar[@REAL_TYPE@]))
                (<PyxConstraintScalar[@REAL_TYPE@]*>cpp_constraints[i]).parameter =\
                        cons._cons_value
            elif cons.is_mat_constraint():
                cpp_constraints[i] = <PyxConstraintMat[@TYPE@]*> \
                        PyMem_Malloc(sizeof(PyxConstraintMat[@TYPE@]))
                if cons._cons_value is not None: # eg. proj_id has no _cons_value
                    cons._cons_value = cons._cons_value.astype(type2dtype('@TYPE@'))
                    tmp_mat = cons._cons_value
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter =\
                            &tmp_mat[0,0]
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            cons._cons_value_sz
                else:
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            0
            else:
                raise ValueError("Constraint type/name is not recognized.")
            cpp_constraints[i].name = cons.name
            cpp_constraints[i].num_rows = cons._num_rows
            cpp_constraints[i].num_cols = cons._num_cols
            cpp_constraints[i].normalizing = cons.normalized
            cpp_constraints[i].pos = cons.pos
        if p.init_facts:
            # facts have been initialized from the wrapper
            # create a Faust
            F_facts = @CORE_CLASS@(p.init_facts)
            # palm4msa2020_gen in FaustFact.hpp
            # is responsible to delete the object in case the
            # algorithm runs on GPU (hence the transform objects F_facts and
            # core are not the same)

        core = @CORE_CLASS@(core=True)
        core.@CORE_OBJ@ = \
            FaustCoreCy.palm4msa2020[@TYPE@, @REAL_TYPE@](&Mview[0,0], M_num_rows,
                                             M_num_cols,
                                             cpp_constraints,
                                             len(p.constraints),
                                             &outbufview[0],
                                             cpp_stop_crit,
                                             p.is_update_way_R2L,
                                             p.factor_format, p.packing_RL,
                                             p.no_normalization,
                                             p.no_lambda,
                                             cpp_MHTPParams,
                                             p.norm2_max_iter,
                                             p.norm2_threshold,
                                             p.is_verbose,
                                             p.constant_step_size,
                                             p.step_size,
                                             full_gpu,
                                             <FaustCoreCy.@CPP_CORE_CLASS@[@TYPE@]*>NULL
                                             if not p.init_facts else
                                             F_facts.@CORE_OBJ@)

        if p.init_facts:
            F_facts.@CORE_OBJ@ = NULL
            # needed to avoid double-free (because F_facts has the same
            # TransformHelper behind as core)

        for i in range(0,len(p.constraints)):
            PyMem_Free(cpp_constraints[i])
        PyMem_Free(cpp_constraints)

        if(core.@CORE_OBJ@ == NULL): raise Exception("palm4msa2020"
                                                     " has failed.");

        return core, _out_buf[0]

    @staticmethod
    def hierarchical2020(M, p, full_gpu=False):

        cdef unsigned int M_num_rows=M.shape[0]
        cdef unsigned int M_num_cols=M.shape[1]

        cdef @TYPE@[:,:] Mview

        # view for lambda
        cdef @REAL_TYPE@[:] outbufview

        cdef @TYPE@[:,:] tmp_mat

        cdef PyxConstraintGeneric** cpp_constraints

        M = np.asfortranarray(M)
        is_update_way_R2L = p.is_update_way_R2L
        is_fact_side_left = p.is_fact_side_left
        factor_format = p.factor_format
        packing_RL = p.packing_RL
        norm2_max_iter = p.norm2_max_iter
        norm2_threshold = p.norm2_threshold
        no_normalization = p.no_normalization
        no_lambda = p.no_lambda
        cdef PyxMHTPParams[@REAL_TYPE@] cpp_MHTPParams
        cdef PyxStoppingCriterion[@REAL_TYPE@]* cpp_stop_crits
        cpp_stop_crits = <PyxStoppingCriterion[@REAL_TYPE@]*>\
        PyMem_Malloc(sizeof(PyxStoppingCriterion[@REAL_TYPE@])*2)


        cpp_stop_crits[0].is_criterion_error = p.stop_crits[0]._is_criterion_error
        cpp_stop_crits[0].error_threshold = p.stop_crits[0].tol
        cpp_stop_crits[0].num_its = p.stop_crits[0].num_its
        cpp_stop_crits[0].max_num_its = p.stop_crits[0].maxiter
        cpp_stop_crits[1].is_criterion_error = p.stop_crits[1]._is_criterion_error
        cpp_stop_crits[1].error_threshold = p.stop_crits[1].tol
        cpp_stop_crits[1].num_its = p.stop_crits[1].num_its
        cpp_stop_crits[1].max_num_its = p.stop_crits[1].maxiter

        # use_MHTP is either False or a MHTPParams instance
        if p.use_MHTP != False:
            mhtpp = p.use_MHTP
            cpp_MHTPParams.used = True
            cpp_MHTPParams.stop_crit.is_criterion_error = mhtpp.stop_crit._is_criterion_error
            cpp_MHTPParams.stop_crit.error_threshold = mhtpp.stop_crit.tol
            cpp_MHTPParams.stop_crit.num_its = mhtpp.stop_crit.num_its
            cpp_MHTPParams.stop_crit.max_num_its = mhtpp.stop_crit.maxiter
            cpp_MHTPParams.constant_step_size = mhtpp.constant_step_size
            cpp_MHTPParams.step_size = mhtpp.step_size
            cpp_MHTPParams.updating_lambda = mhtpp.updating_lambda
            cpp_MHTPParams.palm4msa_period = mhtpp.palm4msa_period
        else:
            cpp_MHTPParams.used = False

        constraints = p.constraints

        # store only lambda as a return from Palm4MSA algo
        _out_buf = np.array([0], dtype=type2dtype('@REAL_TYPE@'))
        _out_buf[0] = p.init_lambda;

        Mview=M
        outbufview = _out_buf

        num_constraints = len(constraints)
        num_facts = int(num_constraints/2+1)

        cpp_constraints = \
        <PyxConstraintGeneric**> \
        PyMem_Malloc(sizeof(PyxConstraintGeneric*)*num_constraints)


        for i in range(0,num_constraints):
            cons = constraints[i]
            if(cons.is_int_constraint()):
                cpp_constraints[i] = <PyxConstraintInt*> PyMem_Malloc(sizeof(PyxConstraintInt))
                (<PyxConstraintInt*>cpp_constraints[i]).parameter = cons._cons_value
            elif(cons.is_real_constraint()):
                cpp_constraints[i] = <PyxConstraintScalar[double]*> \
                PyMem_Malloc(sizeof(PyxConstraintScalar[double]))
                (<PyxConstraintScalar[double]*>cpp_constraints[i]).parameter =\
                        cons._cons_value
            elif(cons.is_mat_constraint()):
                cpp_constraints[i] = <PyxConstraintMat[@TYPE@]*> \
                        PyMem_Malloc(sizeof(PyxConstraintMat[@TYPE@]))
                if cons._cons_value is not None: # eg. proj_id has no _cons_value
                    cons._cons_value = cons._cons_value.astype(type2dtype('@TYPE@'))
                    tmp_mat = cons._cons_value
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter =\
                            &tmp_mat[0,0]
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            cons._cons_value_sz
                else:
                    (<PyxConstraintMat[@TYPE@]*>cpp_constraints[i]).parameter_sz =\
                            0
            else:
                raise ValueError("Constraint type/name is not recognized.")
            cpp_constraints[i].name = cons.name
            cpp_constraints[i].num_rows = cons._num_rows
            cpp_constraints[i].num_cols = cons._num_cols
            cpp_constraints[i].normalizing = cons.normalized
            cpp_constraints[i].pos = cons.pos

        p.factor_format = \
        pyfaust.factparams.ParamsFact.factor_format_str2int(p.factor_format)

        core = @CORE_CLASS@(core=True)

        core.@CORE_OBJ@ = \
                FaustCoreCy.hierarchical2020[@TYPE@, @REAL_TYPE@](&Mview[0,0], M_num_rows,
                                                     M_num_cols,
                                                     cpp_stop_crits,
                                                     cpp_constraints,
                                                     num_constraints,
                                                     num_facts,
                                                     &outbufview[0],
                                                     is_update_way_R2L,
                                                     is_fact_side_left,
                                                     p.factor_format,
                                                     packing_RL,
                                                     no_normalization,
                                                     no_lambda,
                                                     cpp_MHTPParams,
                                                     norm2_max_iter,
                                                     norm2_threshold,
                                                     p.is_verbose,
                                                     p.constant_step_size,
                                                     p.step_size,
                                                     full_gpu)

        for i in range(0,num_constraints):
            PyMem_Free(cpp_constraints[i])
        PyMem_Free(cpp_constraints)
        PyMem_Free(cpp_stop_crits)
        if(core.@CORE_OBJ@ == NULL): raise Exception("hierarchical2020"
                                                          " has failed.");

        return core, _out_buf[0]

    @staticmethod
    def butterfly_hierarchical(M, dir):

        cdef unsigned int M_num_rows=M.shape[0]
        cdef unsigned int M_num_cols=M.shape[1]

        cdef @TYPE@[:,:] Mview

        if dir == "right":
            dir = 1
        elif dir == "left":
            dir = 0
        elif dir == "bbtree":
            dir = 2
        else:
            raise ValueError("dir argument must be 'right' or 'left'.")


        core = @CORE_CLASS@(core=True)
        Mview = M
        core.@CORE_OBJ@ = \
        FaustCoreCy.butterfly_hierarchical[@TYPE@](&Mview[0,0], M_num_rows,
                                                   M_num_cols, dir)

        return core


    @staticmethod
    def polyCoeffs(d, basisX, coeffs, dev, out=None):
        K = coeffs.size-1
        # basisX must be a numpy array in fortran column major order and dtype @TYPE@128
        if basisX.ndim > 1:
            n = basisX.shape[1]
        else:
            n = 1

        ndim_M=basisX.ndim

        if (ndim_M > 2) | (ndim_M < 1):
            raise ValueError('input basisX invalid number of dimensions')

        cdef unsigned int nbrow_x=basisX.shape[0]
        cdef unsigned int nbcol_x #can't be assigned because we don't know yet if the input vector is 1D or 2D

        cdef unsigned int nbrow_y=d
        cdef unsigned int nbcol_y=n

        cdef @TYPE@[:] bxview_1D
        cdef @TYPE@[:,:] bxview_2D

        cdef @TYPE@[:] cview

        cdef y
        cdef @TYPE@[:,:] yview

        if ndim_M == 1:
            nbcol_x=1
            bxview_1D = basisX
        else:
            nbcol_x=basisX.shape[1]
            bxview_2D=basisX

        # TODO: make some sanity checks on argument sizes

        cview = coeffs

        if not isinstance(out, type(None)):
            y = out
            if y.ndim == 1:
                raise ValueError('out must have 2 dimensions.')
            if y.shape != (d,n):
                raise ValueError('out shape isn\'t valid.')
            dtype_err = ValueError('out dtype isn\'t valid.')
            if not y.flags['F_CONTIGUOUS']:
                raise ValueError('the array must be in fortran/column continous order.')
            if y.dtype != type2dtype('@TYPE@'):
                raise dtype_err
            yview = y
        else:
            y = np.empty((nbrow_y, nbcol_y), dtype='@TYPE@', order='F')
            yview = y

        #void polyCoeffs(int d, int K, int n, const FPP* basisX, const FPP* coeffs, FPP* out) const;
        if ndim_M == 1:
            FaustCoreCy.polyCoeffs(d, K, n, &bxview_1D[0],
                       &cview[0], &yview[0,0], dev.startswith('gpu'))
            y = np.squeeze(y) # we want a single dim. (but we created two
            # above)
        else:
            FaustCoreCy.polyCoeffs(d, K, n, &bxview_2D[0,0],
                       &cview[0], &yview[0,0], dev.startswith('gpu'))
        return y

    @staticmethod
    def polyGroupCoeffs(d, K, basisX, coeffs, dev, out=None):
        # basisX must be a numpy array in fortran column major order
        if basisX.ndim > 1:
            n = basisX.shape[1]
        else:
            n = 1

        ndim_M=basisX.ndim

        if (ndim_M > 2) | (ndim_M < 1):
            raise ValueError('input basisX invalid number of dimensions')

        cdef unsigned int nbrow_x=basisX.shape[0]
        cdef unsigned int nbcol_x #can't be assigned because we don't know yet if the input vector is 1D or 2D

        cdef unsigned int nbrow_y=d
        cdef unsigned int nbcol_y=n

        cdef @TYPE@[:] bxview_1D
        cdef @TYPE@[:,:] bxview_2D

        cdef @TYPE@[:, :] cview

        cdef y
        cdef size_t addr
        cdef @TYPE@** yview

        if ndim_M == 1:
            nbcol_x=1
            bxview_1D = basisX
        else:
            nbcol_x=basisX.shape[1]
            bxview_2D=basisX

        # TODO: make some sanity checks on argument sizes

        if coeffs.ndim != 2:
            raise ValueError('coeffs must have 2 dimensions.')

        if coeffs.shape[1] != K+1:
            raise ValueError('coeffs.shape[1] must be equal to K+1.')

        cview = coeffs

        ncoeffs = coeffs.shape[0]

        yview = <@TYPE@**> PyMem_Malloc(sizeof(@TYPE@**) * ncoeffs)

        if not isinstance(out, type(None)):
            if not isinstance(out, list):
                raise TypeError('out must be a list')
            if len(out) != ncoeffs:
                raise ValueError('out length must agree with coeffs.shape[0]')
            for i in range(ncoeffs):
                y = out[i]
                if y.ndim == 1:
                    raise ValueError('out must have 2 dimensions.')
                if y.shape != (d,n):
                    raise ValueError('out shape isn\'t valid.')
                dtype_err = ValueError('out dtype isn\'t valid.')
                if not y.flags['F_CONTIGUOUS']:
                    raise ValueError('the array must be in fortran/column continous order.')
                if y.dtype != type2dtype('@TYPE@'):
                    raise dtype_err
                addr = y.__array_interface__['data'][0]
                yview[i] = <@TYPE@*> addr
        else:
            out = []
            for i in range(ncoeffs):
                out.append(np.empty((nbrow_y, nbcol_y), dtype='@TYPE@',
                                    order='F'))
                addr = out[i].__array_interface__['data'][0]
                yview[i] = <@TYPE@*> addr

        if ndim_M == 1:
            FaustCoreCy.polyGroupCoeffs_(d, K, n, &bxview_1D[0],
                       &cview[0,0], yview, ncoeffs, dev.startswith('gpu'))
        else:
            FaustCoreCy.polyGroupCoeffs_(d, K, n, &bxview_2D[0,0],
                       &cview[0,0], yview, ncoeffs, dev.startswith('gpu'))

        PyMem_Free(yview)

        return out

    @staticmethod
    def polyBasis(L, K, T0=None, on_gpu=False):
        cdef int[:] colind_view, rowptr_view
        cdef @TYPE@[:] cplx_vals_view
        cdef int[:] T0_colind_view, T0_rowptr_view
        cdef @TYPE@[:] T0_cplx_vals_view
        core = @CORE_CLASS@(core=True)
        if not isinstance(T0, type(None)):
            if not isinstance(T0, csr_matrix):
                raise TypeError("T0 must be a csr_matrix")
            else:
                if T0.shape[0] != L.shape[0]:
                    raise ValueError("T0 must agree.")
                if T0.dtype != L.dtype:
                    raise TypeError("T0 and L must have the same dtype.")
                T0_cplx_vals_view = T0.data
                T0_colind_view = T0.indices
                T0_rowptr_view = T0.indptr
        colind_view = L.indices
        rowptr_view = L.indptr
        cplx_vals_view = L.data
        if isinstance(T0, type(None)):
            core.@CORE_OBJ@ = \
            FaustCoreCy.@CPP_CORE_CLASS@[@TYPE@].polyBasis(L.shape[0], L.shape[1],
                                                       &rowptr_view[0],
                                                       &colind_view[0],
                                                        &cplx_vals_view[0],
                                                        L.nnz,
                                                        K,
                                                        on_gpu)
        else:
            core.@CORE_OBJ@ = \
                    FaustCoreCy.@CPP_CORE_CLASS@[@TYPE@].polyBasis_ext(L.shape[0], L.shape[1],
                                                                &rowptr_view[0],
                                                                &colind_view[0],
                                                                &cplx_vals_view[0],
                                                                L.nnz,
                                                                K,
                                                                &T0_rowptr_view[0],
                                                                &T0_colind_view[0],
                                                                &T0_cplx_vals_view[0],
                                                                T0.nnz,
                                                                T0.shape[1],
                                                                on_gpu)
        return core



cdef class ConstraintIntCore@TYPE_NAME@:

    # no need to create an object, because project() needs to create core object
    # for each call and for that purpose it needs to determine if mat is real or complex
    # so it can't create the object before the call
    # in that conditions a static method will suffice
    @staticmethod
    def project(M, name, num_rows, num_cols, parameter, normalized=True,
                pos=False):
        cdef @TYPE@[:,:] M_view_cplx
        cdef @TYPE@[:,:] M_out_view_cplx

        M_out = np.empty(M.shape, dtype=M.dtype, order='F')


        M_view_cplx = M
        M_out_view_cplx = M_out
        ret = FaustCoreCy.prox_int[@TYPE@](name, parameter, &M_view_cplx[0,0],
                                      num_rows, num_cols,
                                      &M_out_view_cplx[0,0], normalized,
                                      pos)

        if ret == -1:
            raise ZeroDivisionError("Can't normalize because norm is zero.");
        return M_out

cdef class ConstraintMatCore@TYPE_NAME@:

    @staticmethod
    def project(M, name, num_rows, num_cols, parameter, parameter_sz, normalized=False,
                pos=False):
        cdef @TYPE@[:,:] M_view
        cdef @TYPE@[:,:] M_out_view
        cdef @TYPE@[:,:] param_view

        M_out = np.empty(M.shape, dtype=M.dtype, order='F')



        M_view = M
        M_out_view = M_out
        if parameter is not None:
            parameter = parameter.astype(M.dtype)
            param_view = parameter
        else:
            param_view = np.empty((1,1), dtype=M.dtype)
            parameter_sz = 1
        ret = FaustCoreCy.prox_mat[@TYPE@](name, &param_view[0,0],
                                      parameter_sz, &M_view[0,0],
                                      num_rows, num_cols,
                                      &M_out_view[0,0], normalized,
                                      pos)

        if ret == -1:
            raise ZeroDivisionError("Can't normalize because norm is zero.");
        return M_out

    @staticmethod
    def prox_blockdiag(M, block_shapes, normalized, pos):
        cdef @TYPE@[:,:] M_view
        cdef @TYPE@[:,:] M_out_view
        cdef unsigned long int* m_ptr
        cdef unsigned long int* n_ptr

        M_out = np.empty(M.shape, dtype=M.dtype, order='F')

        n_ptr = <unsigned long*>PyMem_Malloc(sizeof(unsigned long *)*len(block_shapes))
        m_ptr = <unsigned long*>PyMem_Malloc(sizeof(unsigned long *)*len(block_shapes))

        m_ptr[0] = block_shapes[0][0]
        n_ptr[0] = block_shapes[0][1]
        for i in range(1, len(block_shapes)):
            m_ptr[i] = block_shapes[i][0]+m_ptr[i-1]
            n_ptr[i] = block_shapes[i][1]+n_ptr[i-1]

        if(m_ptr[len(block_shapes)-1] != M.shape[0] or n_ptr[len(block_shapes)-1] != M.shape[1]):
            raise ValueError("The sum of block shapes is not equal to the matrix shapes.")

        M_view = M
        M_out_view = M_out
        ret = FaustCoreCy.prox_blockdiag[@TYPE@](&M_view[0,0], M.shape[0],
                                           M.shape[1], &m_ptr[0], &n_ptr[0],
                                          len(block_shapes),normalized, pos,
                                           &M_out_view[0,0])
        PyMem_Free(m_ptr)
        PyMem_Free(n_ptr)

        if ret == -1:
            raise ZeroDivisionError("Can't normalize because norm is zero.");

        return M_out

cdef class ConstraintRealCore@TYPE_NAME@:

    # no need to create an object, because project() needs to create core object
    # for each call and for that purpose it needs to determine if mat is real or complex
    # so it can't create the object before the call
    # in that conditions a static method will suffice
    @staticmethod
    def project(M, name, num_rows, num_cols, parameter, normalized=False,
                pos=False):
        cdef @TYPE@[:,:] M_view_cplx
        cdef @TYPE@[:,:] M_out_view_cplx

        M_out = np.empty(M.shape, dtype=M.dtype, order='F')

        M_view_cplx = M
        M_out_view_cplx = M_out
        ret = FaustCoreCy.prox_real[@TYPE@, double](name, parameter, &M_view_cplx[0,0],
                                      num_rows, num_cols,
                                               &M_out_view_cplx[0,0],
                                               normalized, pos)

        if ret == -1:
            raise ZeroDivisionError("Can't normalize because norm is zero.");

        return M_out
