/****************************************************************************/
/*                              Description:                                */
/*  For more information on the FAuST Project, please visit the website     */
/*  of the project : <http://faust.inria.fr>                                */
/*                                                                          */
/*                              License:                                    */
/*  Copyright (2019):   Hakim HADJ-DJILANI,									*/
/*  					Nicolas Bellot, Adrien Leman, Thomas Gautrais,      */
/*                      Luc Le Magoarou, Remi Gribonval                     */
/*                      INRIA Rennes, FRANCE                                */
/*                      http://www.inria.fr/                                */
/*                                                                          */
/*  The FAuST Toolbox is distributed under the terms of INRIA.              */
/*																			*/
/*  This program is distributed in the hope that it will be useful, but     */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                    */
/*                                                                          */
/*  More information about license: http://faust.inria.fr                   */
/*                                                                          */
/*                             Contacts:                                    */
/*      Nicolas Bellot  : nicolas.bellot@inria.fr                           */
/*      Adrien Leman    : adrien.leman@inria.fr                             */
/*      Thomas Gautrais : thomas.gautrais@inria.fr                          */
/*      Luc Le Magoarou : luc.le-magoarou@inria.fr                          */
/*      Remi Gribonval  : remi.gribonval@inria.fr                           */
/*                                                                          */
/*                              References:                                 */
/*  [1] Le Magoarou L. and Gribonval R., "Flexible multi-layer sparse       */
/*  approximations of matrices and applications", Journal of Selected       */
/*  Topics in Signal Processing, 2016.                                      */
/*  <https://hal.archives-ouvertes.fr/hal-01167948v1>                       */


#include "mex.h"
#include "faust_GivensFGFT.h"
#include "faust_GivensFGFTParallel.h"
#include "faust_GivensFGFTComplex.h"
#include "faust_GivensFGFTParallelComplex.h"
#include "faust_SVDTJ.h"
#include "faust_TransformHelper.h"
#include "faust_linear_algebra.h"
#include "class_handle.hpp"
#include "faust_Vect.h"
#include "faust_MatSparse.h"
#include <vector>
#include <string>
#include <algorithm>
#include "mx2Faust.h"
#include "faust2Mx.h"
#include <stdexcept>

typedef @FAUST_SCALAR@ SCALAR;
//typedef complex<SCALAR> CPLX_SCALAR; // re-enable if one day complex<float> is supported
typedef complex<double> CPLX_SCALAR;

using namespace Faust;

//void svdtj_cplx(const mxArray* matlab_matrix, int J, int t, double tol, unsigned int verbosity, bool relErr, int order, const bool enable_large_Faust mxArray **plhs);

void svdtj(const mxArray* matlab_matrix, int J, int t, Real<SCALAR> tol, unsigned int verbosity, bool relErr, int order, const bool enable_large_Faust, mxArray **plhs);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{

	int J;
	int t = 1; // default value for non-parallel Givens FGFT
	unsigned int verbosity = 0; //default verbosity (no info. displayed)
	Real<SCALAR> tol = 0;
	bool relErr = true;
	int order = -1;
	bool enable_large_Faust = false;

	if(nrhs < 2 || nrhs > 8)
		mexErrMsgTxt("Bad Number of input arguments");

	J = (int) mxGetScalar(prhs[1]);
	if(nrhs >= 3)
		t = (int) mxGetScalar(prhs[2]);
	if(nrhs >= 4)
		verbosity = (int) mxGetScalar(prhs[3]);
	if(nrhs >= 5)
		tol = (Real<SCALAR>) mxGetScalar(prhs[4]);
	if(nrhs >= 6)
		relErr = (bool) mxGetScalar(prhs[5]);
	if(nrhs >= 7)
		order = (int) mxGetScalar(prhs[6]); //eigenvalues order
	if(nrhs >= 8)
		enable_large_Faust = (bool) mxGetScalar(prhs[7]);

	tol *= tol; // C++ backend works with squared norm error
	const mxArray* matlab_matrix = prhs[0]; // Laplacian

//	if(mxIsComplex(matlab_matrix))
//		svdtj_cplx(matlab_matrix, J, t, tol, verbosity, relErr, order, plhs);
//	else
	svdtj(matlab_matrix, J, t, tol, verbosity, relErr, order, enable_large_Faust, plhs);

}

void svdtj(const mxArray* matlab_matrix, int J, int t, Real<SCALAR> tol, unsigned int verbosity, bool relErr, int order, const bool enable_large_Faust, mxArray **plhs)
{
	Faust::MatDense<SCALAR,Cpu> dM;
	Faust::MatSparse<SCALAR,Cpu> sM;
	TransformHelper<SCALAR,Cpu> *U = nullptr, *V = nullptr;
	Faust::Vect<SCALAR,Cpu>* S;
	Faust::MatDense<CPLX_SCALAR,Cpu> dM_cplx;
	Faust::MatSparse<CPLX_SCALAR,Cpu> sM_cplx;
	TransformHelper<CPLX_SCALAR,Cpu> *U_cplx = nullptr, *V_cplx = nullptr;
	Faust::Vect<CPLX_SCALAR,Cpu>* S_cplx;



	bool M_is_cplx = mxIsComplex(matlab_matrix);

	try{
		if(M_is_cplx)
		{
			if (mxIsSparse(matlab_matrix))
			{
				mxArray2FaustspMat(matlab_matrix,sM_cplx);
				svdtj_cplx<CPLX_SCALAR,Cpu,Real<CPLX_SCALAR>>(sM_cplx, J, t, tol, verbosity, relErr, order, enable_large_Faust, &U_cplx, &V_cplx, &S_cplx);
			}else
			{
				mxArray2FaustMat(matlab_matrix, dM_cplx);
				svdtj_cplx<CPLX_SCALAR,Cpu,Real<CPLX_SCALAR>>(dM_cplx, J, t, tol, verbosity, relErr, order, enable_large_Faust, &U_cplx, &V_cplx, &S_cplx);
			}
			if(U_cplx != nullptr)
			{
				plhs[0] = convertPtr2Mat<Faust::TransformHelper<CPLX_SCALAR, Cpu>>(U_cplx);
				plhs[1] = FaustVec2mxArray(*S_cplx);
				plhs[2] = convertPtr2Mat<Faust::TransformHelper<CPLX_SCALAR, Cpu>>(V_cplx);
				delete S_cplx; //allocated internally by Faust::svdtj

			}
		}
		else
		{
			if (mxIsSparse(matlab_matrix))
			{
				mxArray2FaustspMat(matlab_matrix,sM);
				svdtj(sM, J, t, tol, verbosity, relErr, order, enable_large_Faust, &U, &V, &S);
			}else
			{
				mxArray2FaustMat(matlab_matrix, dM);
				svdtj(dM, J, t, tol, verbosity, relErr, order, enable_large_Faust, &U, &V, &S);
			}
			if(U != nullptr)
			{
               plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR, Cpu>>(U);
               plhs[1] = FaustVec2mxArray(*S);
               plhs[2] = convertPtr2Mat<Faust::TransformHelper<SCALAR, Cpu>>(V);
			   delete S; //allocated internally by Faust::svdtj
			}
		}
	}
	catch (const std::exception& e)
	{
		mexErrMsgTxt(e.what());
	}
	if(U_cplx == nullptr && U == nullptr)
		mexErrMsgTxt("Empty transform (nGivens is too big ? Set enable_large_Faust to true to force the computation).");
}
