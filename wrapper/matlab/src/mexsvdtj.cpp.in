/****************************************************************************/
/*                              Description:                                */
/*  For more information on the FAuST Project, please visit the website     */
/*  of the project : <http://faust.inria.fr>                                */
/*                                                                          */
/*                              License:                                    */
/*  Copyright (2019):   Hakim HADJ-DJILANI,									*/
/*  					Nicolas Bellot, Adrien Leman, Thomas Gautrais,      */
/*                      Luc Le Magoarou, Remi Gribonval                     */
/*                      INRIA Rennes, FRANCE                                */
/*                      http://www.inria.fr/                                */
/*                                                                          */
/*  The FAuST Toolbox is distributed under the terms of INRIA.              */
/*																			*/
/*  This program is distributed in the hope that it will be useful, but     */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                    */
/*                                                                          */
/*  More information about license: http://faust.inria.fr                   */
/*                                                                          */
/*                             Contacts:                                    */
/*      Nicolas Bellot  : nicolas.bellot@inria.fr                           */
/*      Adrien Leman    : adrien.leman@inria.fr                             */
/*      Thomas Gautrais : thomas.gautrais@inria.fr                          */
/*      Luc Le Magoarou : luc.le-magoarou@inria.fr                          */
/*      Remi Gribonval  : remi.gribonval@inria.fr                           */
/*                                                                          */
/*                              References:                                 */
/*  [1] Le Magoarou L. and Gribonval R., "Flexible multi-layer sparse       */
/*  approximations of matrices and applications", Journal of Selected       */
/*  Topics in Signal Processing, 2016.                                      */
/*  <https://hal.archives-ouvertes.fr/hal-01167948v1>                       */


#include "mex.h"
#include "faust_GivensFGFT.h"
#include "faust_GivensFGFTParallel.h"
#include "faust_GivensFGFTComplex.h"
#include "faust_GivensFGFTParallelComplex.h"
#include "faust_SVDTJ.h"
#include "faust_TransformHelper.h"
#include "faust_linear_algebra.h"
#include "class_handle.hpp"
#include "faust_Vect.h"
#include "faust_MatSparse.h"
#include <vector>
#include <string>
#include <algorithm>
#include "mx2Faust.h"
#include "faust2Mx.h"
#include <stdexcept>

typedef @FAUST_SCALAR@ SCALAR;
typedef @FACT_FPP@ FPP2;

using namespace Faust;

//void svdtj_cplx(const mxArray* matlab_matrix, int J, int t, double tol, unsigned int verbosity, bool relErr, int order, mxArray **plhs);

void svdtj(const mxArray* matlab_matrix, int J, int t, double tol, unsigned int verbosity, bool relErr, int order, mxArray **plhs);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{

	int J;
	int t = 1; // default value for non-parallel Givens FGFT
	unsigned int verbosity = 0; //default verbosity (no info. displayed)
	double tol = 0;
	bool relErr = true;
	int order;

	if(nrhs < 2 || nrhs > 7)
		mexErrMsgTxt("Bad Number of inputs arguments");

	J = (int) mxGetScalar(prhs[1]);
	if(nrhs >= 3)
		t = (int) mxGetScalar(prhs[2]);
	if(nrhs >= 4)
		verbosity = (int) mxGetScalar(prhs[3]);
	if(nrhs >= 5)
		tol = (double) mxGetScalar(prhs[4]);
	if(nrhs >= 6)
		relErr = (bool) mxGetScalar(prhs[5]);
	if(nrhs >= 7)
		order = (int) mxGetScalar(prhs[6]); //eigenvalues order

	tol *= tol; // C++ backend works with squared norm error
	const mxArray* matlab_matrix = prhs[0]; // Laplacian

//	if(mxIsComplex(matlab_matrix))
//		svdtj_cplx(matlab_matrix, J, t, tol, verbosity, relErr, order, plhs);
//	else
	svdtj(matlab_matrix, J, t, tol, verbosity, relErr, order, plhs);

}

void svdtj(const mxArray* matlab_matrix, int J, int t, double tol, unsigned int verbosity, bool relErr, int order, mxArray **plhs)
{
	Faust::MatDense<SCALAR,Cpu> dM;
	Faust::MatSparse<SCALAR,Cpu> sM;
	TransformHelper<SCALAR,Cpu> *U, *V;
	Faust::Vect<SCALAR,Cpu>* S;
	Faust::MatDense<complex<SCALAR>,Cpu> dM_cplx;
	Faust::MatSparse<complex<SCALAR>,Cpu> sM_cplx;
	TransformHelper<complex<SCALAR>,Cpu> *U_cplx, *V_cplx;
	Faust::Vect<complex<SCALAR>,Cpu>* S_cplx;

	Faust::BlasHandle<Cpu> blas_handle;
	Faust::SpBlasHandle<Cpu> spblas_handle;


	bool M_is_cplx = mxIsComplex(matlab_matrix);

	try{
		if(M_is_cplx)
		{
			if (mxIsSparse(matlab_matrix))
			{
				mxArray2FaustspMat(matlab_matrix,sM_cplx);
				svdtj_cplx<complex<SCALAR>,Cpu,FPP2>(sM_cplx, J, t, tol, verbosity, relErr, order, &U_cplx, &V_cplx, &S_cplx);
			}else
			{
				mxArray2FaustMat(matlab_matrix, dM_cplx);
				svdtj_cplx<complex<SCALAR>,Cpu,FPP2>(dM_cplx, J, t, tol, verbosity, relErr, order, &U_cplx, &V_cplx, &S_cplx);
			}
			plhs[0] = convertPtr2Mat<Faust::TransformHelper<complex<SCALAR>, Cpu>>(U_cplx);
			plhs[1] = FaustVec2mxArray(*S_cplx);
			plhs[2] = convertPtr2Mat<Faust::TransformHelper<complex<SCALAR>, Cpu>>(V_cplx);
			delete S_cplx;
		}
		else
		{
			if (mxIsSparse(matlab_matrix))
			{
				mxArray2FaustspMat(matlab_matrix,sM);
				svdtj(sM, J, t, tol, verbosity, relErr, order, &U, &V, &S);
			}else
			{
				mxArray2FaustMat(matlab_matrix, dM);
				svdtj(dM, J, t, tol, verbosity, relErr, order, &U, &V, &S);
			}
               plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR, Cpu>>(U);
               plhs[1] = FaustVec2mxArray(*S);
               plhs[2] = convertPtr2Mat<Faust::TransformHelper<SCALAR, Cpu>>(V);
               delete S; //allocated internally by Faust::svdtj
		}
	}
	catch (const std::exception& e)
	{
		mexErrMsgTxt(e.what());
	}
}
