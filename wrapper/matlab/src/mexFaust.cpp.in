/****************************************************************************/
/*                              Description:                                */
/*    file where the C++ class Faust::Transform is interface with Matlab    */
/*   WARNING : this file is configured into two files :                     */
/* - mexFaustReal.cpp interfaces the class Faust::Transform<double>         */
/*     (i.e real scalar Faust)                                              */
/* - mexFaustCplx.cpp interfaces the                                        */
/* class Faust::Transform<std::complex<double<>                             */
/*  (i.e complex scalar Faust)                                              */
/* --> these 2 mexfunctions are directly used                               */
/*                                                                          */
/* by FaustCore class (tools/FaustCore.m) and Faust.m                       */
/*                                                                          */
/*  For more information on the FAuST Project, please visit the website     */
/*  of the project : <http://faust.inria.fr>                         */
/*                                                                          */
/*                              License:                                    */
/*  Copyright (2016):   Nicolas Bellot, Adrien Leman, Thomas Gautrais,      */
/*                      Luc Le Magoarou, Remi Gribonval                     */
/*                      INRIA Rennes, FRANCE                                */
/*                      http://www.inria.fr/                                */
/*                                                                          */
/*  The FAuST Toolbox is distributed under the terms of the GNU Affero      */
/*  General Public License.                                                 */
/*  This program is free software: you can redistribute it and/or modify    */
/*  it under the terms of the GNU Affero General Public License as          */
/*  published by the Free Software Foundation.                              */
/*                                                                          */
/*  This program is distributed in the hope that it will be useful, but     */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                    */
/*  See the GNU Affero General Public License for more details.             */
/*                                                                          */
/*  You should have received a copy of the GNU Affero General Public        */
/*  License along with this program.                                        */
/*  If not, see <http://www.gnu.org/licenses/>.                             */
/*                                                                          */
/*                             Contacts:                                    */
/*      Nicolas Bellot  : nicolas.bellot@inria.fr                           */
/*      Adrien Leman    : adrien.leman@inria.fr                             */
/*      Thomas Gautrais : thomas.gautrais@inria.fr                          */
/*      Luc Le Magoarou : luc.le-magoarou@inria.fr                          */
/*      Remi Gribonval  : remi.gribonval@inria.fr                           */
/*                                                                          */
/*                              References:                                 */
/*  [1] Le Magoarou L. and Gribonval R., "Flexible multi-layer sparse       */
/*  approximations of matrices and applications", Journal of Selected       */
/*  Topics in Signal Processing, 2016.                                      */
/*  <https://hal.archives-ouvertes.fr/hal-01167948v1>                       */


#include "mex.h"
#include "class_handle.hpp"
#include "faust_Transform.h"
#include "faust_TransformHelper.h"
#include "mx2Faust.h"
#include "faust2Mx.h"
#include "faust_MatDense.h"
#include "faust_MatSparse.h"
#include <stdexcept>
#include "faust_constant.h"
#include "faust_Timer.h"
#include <complex>
// prhs[0] : name of command :
//    "delete" to delete the Faust::Transform<SCALAR> object dynamically allocated previously
//    "multiply" to multiply the Faust::Transform<SCALAR> object by a vector or a matrix

// prhs[1] : address of the Faust::Transform<SCALAR> object dynamically allocated previously

// prhs[2] (only necessary if prhs[0] matches "multiply") : vector or matrix A to multiply by the Faust::Transform<SCALAR> object



typedef @FAUST_SCALAR@ SCALAR;

using namespace Faust;

void save(Faust::TransformHelper<SCALAR,Cpu>* core_ptr, int nargs, const mxArray **args)
{
	size_t MAX_PATH_SIZE=512;
	char filepath[MAX_PATH_SIZE];
	// args[0] must be the filepath
    // args[1] must be the boolean for tranposing or not at write time
	// nargs the number of arguments in args (must be 2)
    if(nargs != 1){
            mexErrMsgTxt("The number of arguments for the save function is not valid.");
            return;
        }
        if(mxGetString(args[0], filepath, sizeof(filepath)) || strlen(filepath) == 0){
            mexErrMsgTxt("The filepath is not valid.");
            return;
        }
        //	printf("save: filepath = %s, nargs = %d\n", filepath, nargs);
        core_ptr->save_mat_file(filepath/*, mxGetScalar(args[1])*/);
    }

    void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
    {
#ifdef FAUST_VERBOSE
        if (typeid(SCALAR) == typeid(float))
        {
            std::cout<<"SCALAR == float"<<std::endl;
        }

        if (typeid(SCALAR) == typeid(double))
        {
            std::cout<<"SCALAR == double"<<std::endl;
        }
#endif
        try{
			// Get the command string
			char cmd[256];
			if (nrhs < 1 || mxGetString(prhs[0], cmd, sizeof(cmd)))
				mexErrMsgTxt("First input should be a command string less than 256 characters long.");
			// Check there is a second input, which should be the class instance handle
			if (nrhs < 2)
				mexErrMsgTxt("Second input should be a class instance handle.");

			if(!strcmp("rand", cmd)){
				if(nlhs!=1)
					mexErrMsgTxt("rand(): 1 variable result is expected.");
				if(nrhs < 6)
					mexErrMsgTxt("rand(): wrong number of arguments (must be 6 to 7)");
				//printf("mexFaust.cpp rand(): retrieving arguments\n");
				faust_unsigned_int t = (faust_unsigned_int) mxGetScalar(prhs[1]),
								   min_num_factors = (faust_unsigned_int) mxGetScalar(prhs[2]),
								   max_num_factors = (faust_unsigned_int) mxGetScalar(prhs[3]),
								   min_dim_size = (faust_unsigned_int) mxGetScalar(prhs[4]),
								   max_dim_size = (faust_unsigned_int) mxGetScalar(prhs[5]);
				float density = (float) mxGetScalar(prhs[6]);

				//printf("mexFaust.cpp rand(): faust creation\n");
				Faust::TransformHelper<SCALAR,Cpu>* F = Faust::TransformHelper<SCALAR,Cpu>::randFaust(RandFaustType(t), min_num_factors, max_num_factors, min_dim_size, max_dim_size, density);

				if(F) //not NULL
					plhs[0]=convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(F);
				else {
					plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
					double* ptr_out = (double*) mxGetData(plhs[0]);
					ptr_out[0]=(double) 0;
				}
				return;

		}

            // New
            if (!strcmp("new", cmd))
            {

                if(nlhs!=1)
                    mexErrMsgTxt("1 output is expected.");
                if((nrhs<2) || (nrhs>4))
                    mexErrMsgTxt("between 1 and 3 inputs are expected.");


                if(!mxIsCell(prhs[1]))
                    mexErrMsgTxt("1st arg input must be a cell-array");

                // v1105 : Faust::Transform<SCALAR,Cpu> is no longer made of Faust::MatSparse<SCALAR,Cpu> but of pointer of abstract class Faust::MatGeneric<SCALAR,Cpu>
                //old version : std::vector<Faust::MatSparse<SCALAR,Cpu> > vec_spmat;
                std::vector<Faust::MatGeneric<SCALAR,Cpu>*> list_factor;
                mwSize nb_element = mxGetNumberOfElements(prhs[1]);



                if (nb_element != 0)
                {
                    mxArray * mxMat;
                    for (int i=0; i < nb_element; i++)
                    {
                        mxMat=mxGetCell(prhs[1],i);

                        concatMatGeneric<SCALAR>(mxMat,list_factor);

                    }
                }

                // 2nd input (optionnal) : multiplicative scalar
                SCALAR lambda = 1.0;
                if (nrhs > 2)
                    lambda = (SCALAR) mxGetScalar(prhs[2]);


                // 3rd input (optionnal) : boolean to determine the type of copy
                bool optimizedCopy = true;
                if (nrhs > 3)
                {
                    double optimizedCopy_inter = mxGetScalar(prhs[3]);
                    if ((optimizedCopy_inter != 1.0) and (optimizedCopy_inter != 0.0))
                        mexErrMsgTxt("invalid boolean argument.");

                    optimizedCopy = (bool) optimizedCopy_inter;

                }


                Faust::TransformHelper<SCALAR,Cpu>* F = new Faust::TransformHelper<SCALAR,Cpu>(list_factor, lambda, optimizedCopy);
                for (int i=0;i<list_factor.size();i++)
                    delete list_factor[i];

                plhs[0]=convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(F);

                return;
            }




            // Delete
            if (!strcmp("delete", cmd))
            {
                // Destroy the C++ object
                destroyObject<Faust::TransformHelper<SCALAR,Cpu> >(prhs[1]);
                // Warn if other commands were ignored
                if (nlhs != 0 || nrhs != 2)
                    mexWarnMsgTxt("Delete: Unexpected arguments ignored.");
                return;
            }


            // Get the class instance pointer from the second input
            Faust::TransformHelper<SCALAR,Cpu>* core_ptr = convertMat2Ptr<Faust::TransformHelper<SCALAR,Cpu> >(prhs[1]);
#ifdef FAUST_VERBOSE
            printf("cmd = %s, core_ptr = %p\n", cmd, core_ptr);
#endif

            if (!strcmp("size",cmd))
            {
                const size_t SIZE_B1 = core_ptr->getNbRow();
                const size_t SIZE_B2 = core_ptr->getNbCol();
                const mwSize dims[2]={1,2};
                plhs[0]=mxCreateNumericArray(2,dims,mxDOUBLE_CLASS,mxREAL);
                double* ptr_out = (double*) mxGetData(plhs[0]);
                ptr_out[0]=(double) SIZE_B1;
                ptr_out[1]=(double) SIZE_B2;
                return;
            }

            if (!strcmp("isReal",cmd))
            {
                plhs[0] = mxCreateDoubleScalar((double) core_ptr->isReal());
                return;
            }
            // return the number of non zeros coefficients of the matrix
            if (!strcmp("nnz",cmd))
            {
                if (nlhs > 1 || nrhs != 2)
                {
                    mexErrMsgTxt("nnz : incorrect number of arguments.");
                }

                long long int nnz = core_ptr->get_total_nnz();
                plhs[0]=mxCreateDoubleScalar(nnz);
                return;
            }

            // get_fact : return the id factor of the faust
            if (!strcmp("get_fact", cmd))
            {
                if (nlhs > 1 || nrhs != 3)
                {
                    mexErrMsgTxt("get_fact : incorrect number of arguments.");
                }
                int id_fact = (faust_unsigned_int) (mxGetScalar(prhs[2])-1);

                Faust::MatDense<SCALAR,Cpu> dense_factor = core_ptr->get_fact(id_fact);

                //*conversion to mxArray*/
                plhs[0]=FaustMat2mxArray(dense_factor);
                return;
            }


            if (!strcmp("get_nb_factor", cmd))
            {
                if (nlhs != 1 || nrhs != 2)
                {
                    mexErrMsgTxt("get_nb_factor : incorrect number of arguments.");
                }

                faust_unsigned_int nb_fact = core_ptr->size();
                plhs[0] = mxCreateDoubleMatrix(1,1,mxREAL);
                double* ptr_out = (double*) mxGetData(plhs[0]);
                ptr_out[0]=(double) nb_fact;
                return;


            }

            if (!strcmp("disp",cmd))
            {
                if (nlhs != 0 || nrhs != 2)
                    mexErrMsgTxt("disp: Unexpected arguments");
                //core_ptr->display(); // doesn't work on windows,
					// matlab terminal doesn't receive the mex lib std output
					// we must use mexPrintf() to display content
		mexPrintf(core_ptr->to_string().c_str());
                return;
            }


            if (!strcmp("full",cmd))
            {

                if (nlhs != 1 || nrhs != 2)
                    mexErrMsgTxt("full: Unexpected arguments");
                if(core_ptr->size() == 0)
                    mexErrMsgTxt("full : empty faust core");

                faust_unsigned_int nbRowOp,nbColOp;
                const size_t SIZE_B1 = core_ptr->getNbRow();
                const size_t SIZE_B2 = core_ptr->getNbCol();
                Faust::MatDense<SCALAR,Cpu> prod=core_ptr->get_product();
                const mwSize dims[2]={SIZE_B1,SIZE_B2};


                plhs[0] = FaustMat2mxArray(prod);
                return;
            }

            // compute the 2-norm of the faust
            if (!strcmp("norm",cmd))
            {
                if (nlhs != 1 || nrhs != 3)
                    mexErrMsgTxt("norm: Unexpected arguments");
                if(core_ptr->size() == 0)
                    mexErrMsgTxt("norm : empty faust core");


                double precision =  0.001;
                faust_unsigned_int nbr_iter_max=100;
                int flag;
                int ord = (int) mxGetScalar(prhs[2]);
                //printf("mexFaust.cpp norm() ord=%d\n", ord);
                //spectralNorm(const int nbr_iter_max, FPP threshold, int &flag) const;

                double norm_faust;

                if(ord==2)
                    norm_faust = (double) core_ptr->spectralNorm(nbr_iter_max,precision,flag);
                else if(ord==1)
                    norm_faust = (double) core_ptr->normL1();
                else
                    mexErrMsgTxt("norm : unvalid norm order.");

                plhs[0]=mxCreateDoubleScalar(norm_faust);

                return;
            }

            if(!strcmp("normfro", cmd))
            {
                if (nlhs != 1 || nrhs != 2)
                    mexErrMsgTxt("normfro: Unexpected arguments");
                if(core_ptr->size() == 0)
                    mexErrMsgTxt("normfro : empty faust core");


                double norm_faust;

                norm_faust = core_ptr->normFro();

                plhs[0]=mxCreateDoubleScalar(norm_faust);

                return;

            }

            if (!strcmp("copy",cmd))
            {



                if (nlhs > 1)
                    mexErrMsgTxt("copy : too much output argument");
                else
                {
                    //Faust::Timer t1,t2,t3;
                    //t1.start();
    //				Faust::Transform<SCALAR,Cpu>* F = new Faust::Transform<SCALAR,Cpu>((*core_ptr));
                    //t1.stop();
                    //t2.start();
                    //(*F).transpose();
                    //t2.stop();
                    //t3.start();
    //				plhs[0]=convertPtr2Mat<Faust::Transform<SCALAR,Cpu> >(F);
    //				plhs[0]=convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(F);
                    //t3.stop();
                    //std::cout<<"t1 new : "<<t1.get_time()<<std::endl;
                    //std::cout<<"t2 transpose : "<<t2.get_time()<<std::endl;
                    //std::cout<<"t3 convertPtrMat : "<<t3.get_time()<<std::endl;
                    TransformHelper<SCALAR,Cpu>* th = new TransformHelper<SCALAR,Cpu>(core_ptr);
                    plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
                }
                return;

            }


            if (!strcmp("multiply", cmd)) {

                if (nlhs > 1 ||  nrhs != 4)
                    mexErrMsgTxt("Multiply: Unexcepted number of arguments.");

                mwSize nelem = mxGetNumberOfElements(prhs[3]);
                if (nelem != 1)
                    mexErrMsgTxt("invalid char argument.");
                // boolean flag to know if the faust needs to be transposed
                bool transpose_flag = (bool) mxGetScalar(prhs[3]);

                // input matrix or vector from MATLAB
                const mxArray * inMatlabMatrix = prhs[2];



                const size_t nbRowA = mxGetM(inMatlabMatrix);
                const size_t nbColA = mxGetN(inMatlabMatrix);
                faust_unsigned_int nbRowOp_,nbColOp_;
                const size_t nbRowOp = core_ptr->getNbRow();
                const size_t nbColOp = core_ptr->getNbCol();
                const size_t nbRowB = nbRowOp;
                const size_t nbColB = nbColA;


                /** Check parameters **/

                //check dimension match
                if (mxGetNumberOfDimensions(inMatlabMatrix) != 2
                        || nbRowA != nbColOp && (nbRowA != nbRowOp && transpose_flag))
                    mexErrMsgTxt("Multiply : Wrong number of dimensions for the input vector or matrix (third argument).");


                SCALAR* ptr_data = NULL;
                if ((core_ptr->isReal() ) && ( mxIsComplex(inMatlabMatrix) ) )
                    mexErrMsgTxt("impossibility to multiply real scalar Faust with complex matrix");

                mxArray2Ptr(inMatlabMatrix, ptr_data);

                // Si inMatlabMatrix est un vecteur

                if(nbColA == 1)
                {
                    // applying the Faust to a vector
                    Faust::Vect<SCALAR,Cpu> A(nbRowA, ptr_data);
                    Faust::Vect<SCALAR,Cpu> B(nbRowB);
                    B = (*core_ptr).multiply(A, transpose_flag);


                    plhs[0]=FaustVec2mxArray(B);
                }
                else
                { // applying the Faust to a matrix
                    Faust::MatDense<SCALAR,Cpu> A(ptr_data, nbRowA, nbColA);
                    Faust::MatDense<SCALAR,Cpu> B(nbRowB, nbColA);
                    B = (*core_ptr).multiply(A, transpose_flag);

                    plhs[0]=FaustMat2mxArray(B);

                }



                if(ptr_data) {delete [] ptr_data ; ptr_data = NULL;}

                return;
            }

		if(!strcmp("save", cmd))
			return save(convertMat2Ptr<Faust::TransformHelper<SCALAR,Cpu> >(prhs[1]), nrhs-2, &prhs[2]);

        if(!strcmp("transpose", cmd)) { //TODO: verify no arguments passed or 
            Faust::TransformHelper<SCALAR,Cpu>* th = core_ptr->transpose();
            plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
#ifdef FAUST_VERBOSE
            printf("new ptr for Faust transpose's TransformHelper obj=%p\n", th);
            printf("transpose()\n");
            printf("isTransposed()=%d\n",th->isTransposed());
#endif
            return;
        }

        if(!strcmp("conj", cmd)) { //TODO: verify no arguments passed or 
            Faust::TransformHelper<SCALAR,Cpu>* th = core_ptr->conjugate();
            plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
#ifdef FAUST_VERBOSE
            printf("new ptr for Faust conjugate's TransformHelper obj=%p\n", th);
            printf("conjugate()\n");
            printf("isConjugate()=%d\n",th->isConjugate());
#endif
            return;
        }

        if(!strcmp("ctranspose", cmd)) {
            Faust::TransformHelper<SCALAR,Cpu>* th = core_ptr->adjoint();
            plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
#ifdef FAUST_VERBOSE
            printf("new ptr for Faust conjugate's TransformHelper obj=%p\n", th);
            printf("conjugate()\n");
            printf("isConjugate()=%d\n",th->isConjugate());
            printf("isTransposed()=%d\n", th->isTransposed());
#endif
            return;

        }

		if(!strcmp("subsref", cmd)){
			int start_row_id = (int) mxGetScalar(prhs[2]);
			int end_row_id = (int) mxGetScalar(prhs[3]);
			int start_col_id = (int) mxGetScalar(prhs[4]);
			int end_col_id = (int) mxGetScalar(prhs[5]);
			Faust::TransformHelper<SCALAR, Cpu>* th = core_ptr->slice(start_row_id-1, end_row_id, start_col_id-1, end_col_id);
			plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
			return;
		}

        if(!strcmp("mul_faust", cmd)) {
			Faust::TransformHelper<SCALAR,Cpu>* right_term = convertMat2Ptr<Faust::TransformHelper<SCALAR,Cpu> >(prhs[2]);
			if(right_term->getNbRow() != core_ptr->getNbCol()) mexErrMsgTxt("The dimensions of the two Fausts must agree.");
            Faust::TransformHelper<SCALAR,Cpu>* th = core_ptr->multiply(right_term);
            plhs[0] = convertPtr2Mat<Faust::TransformHelper<SCALAR,Cpu> >(th);
#ifdef FAUST_VERBOSE
            printf("new ptr for Faust multiply's TransformHelper obj=%p\n", th);
            printf("multiply(\"faust\")\n");
            printf("isConjugate()=%d\n",th->isConjugate());
            printf("isTransposed()=%d\n", th->isTransposed());
#endif
            return;

        }
		//     // Call the various class methods
		//     // Train
		//     if (!strcmp("train", cmd)) {
		//         // Check parameters
		//         if (nlhs < 0 || nrhs < 2)
		//             mexErrMsgTxt("Train: Unexpected arguments.");
		//         // Call the method
		//         dummy_instance->train();
		//         return;
		//     }
		//     // Test
		//     if (!strcmp("test", cmd)) {
		//         // Check parameters
		//         if (nlhs < 0 || nrhs < 2)
		//             mexErrMsgTxt("Test: Unexpected arguments.");
		//         // Call the method
		//         dummy_instance->test();
		//         return;
		//     }

		// Got here, so command not recognized
		mexErrMsgTxt("Command not recognized.");
	}catch (const std::exception& e)
	{
		mexErrMsgTxt(e.what());
	}
}
