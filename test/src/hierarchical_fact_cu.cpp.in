#include "faust_cu_mat.h"
#include "faust_core_cu.h"
#include "faust_cu_spmat.h"
#include "faust_cu_vec.h"
#include "faust_constraint_int.h"
#include "faust_constraint_real.h"
#include "faust_params.h"
#include "faust_params_palm.h"
#include "stopping_criterion.h"
#include "faust_init_from_matio_params.h"
#include "faust_init_from_matio_core.h"
#include "palm4MSA_cu.h"
#include "hierarchical_fact_cu.h"
#include "faust_cu_timer.h"
#include "LinAlgebra_cu.h"
#include <iostream>
#include <iomanip>
#include <fstream>

using namespace std;
typedef @TEST_FPP@ faust_real;//faust floating point precision

int main(int argc, char* argv[])
{	
	if (typeid(faust_real) == typeid(double))
  	{
		cout<<"floating point precision == double"<<endl;
  	}
  
  	if (typeid(faust_real) == typeid(float))
  	{
		cout<<"floating point precision == float"<<endl;
  	}
	
	
	string config_filename = "@FAUST_TESTDATA_SRC_DIR@/config_compared_hierarchical_fact.mat"; 
	
	
	
	if (argc >= 2)
		config_filename = argv[1];
	
	size_t ind = config_filename.find_last_of(".");
	
	if(ind<=0 || ind>= config_filename.size())
	{
		cerr << "Le nom du fichier est incorrect" << endl;
		exit(EXIT_FAILURE);
	}
	string config_file_extension(config_filename, ind);
	if(config_file_extension.compare(".mat") != 0)
	{
		cerr << "Le nom du fichier doit se terminer par \".mat\"" << endl;
		exit(EXIT_FAILURE);
	}
	string config_file_body_tmp(config_filename, 0, ind);


	string config_file_body_dir, config_file_body_file;

	ind = config_file_body_tmp.find_last_of("/");
	if(ind<=0 || ind>= config_file_body_tmp.size())
	{
		config_file_body_dir = string("");
		config_file_body_file = config_file_body_tmp;
	}
	else
	{
		config_file_body_dir = string(config_file_body_tmp, 0, ind+1);
		config_file_body_file = string(config_file_body_tmp, ind+1);
	}
	
	
	
	faust_real expected_lambda = 0;	
	if (argc >= 3)
		expected_lambda = atof(argv[2]);
		
		
	faust_real epsilon = 0.0001;
	if (argc >= 4)
		epsilon = atof(argv[3]);
		
	

	// initialisation CUDA environment
	cublasHandle_t cublasHandle;
	cublasStatus_t cublasStat = cublasCreate(&cublasHandle);

	cusparseHandle_t cusparseHandle;
	cusparseStatus_t cusparseStat = cusparseCreate(&cusparseHandle);

	



		faust_params<faust_real> params; 
		init_params_from_matiofile(params,config_filename.c_str(),"params");
		params.Display();
		cout<<"launch"<<endl;	
		hierarchical_fact_cu<faust_real> hier_fact(params, cublasHandle, cusparseHandle);

		faust_cu_timer t1;
		t1.start();
     
		hier_fact.compute_facts();

		t1.stop();
		#ifdef __COMPILE_TIMERS__
		hier_fact.print_timers();
		#endif
		cout <<"total hierarchical fact = "<<t1.get_time()<<endl;

		vector<faust_cu_spmat<faust_real> > facts;
		hier_fact.get_facts(facts);
		
		faust_real lambda=hier_fact.get_lambda();
		cout<<"lambda="<<std::setprecision(20)<<lambda<<endl<<endl;
		
		/// equality test between lambda (multiplied scalar and lambda)
		if (argc >= 3)
		{	
			if (std::abs(lambda - expected_lambda) > epsilon)
			{
				std::cerr<<"invalid lambda, must be equal to "<<std::setprecision(20)<<std::setprecision(20)<<expected_lambda<<" in the precision of "<<epsilon<<std::endl;
				std::cerr<<"current value is "<<std::setprecision(20)<<lambda<<std::endl;
				exit(EXIT_FAILURE); 
			}
		
		}

		

		//faust_core_cu<faust_real> hier_fact_core(facts);
		faust_core_cu<faust_real> hier_fact_core(facts,lambda);


		//write the given factorisation into a mat file
		stringstream outputfilename;
		outputfilename<<"@FAUST_TESTOUTPUT_BIN_DIR@/"<<config_file_body_file<<"_gpu_factorisation.mat";
		std::cout<<"**************** WRITING FACTORISATION INTO ****************"<<std::endl;
		std::cout<<"output filename : "<<outputfilename.str();
		write_faust_core_into_matfile(hier_fact_core,outputfilename.str().c_str(),"fact");

	//relative_error
	faust_cu_mat<faust_real> const data_matrix(params.data);
	faust_cu_mat<faust_real> tmp;
	tmp=hier_fact_core.get_product(cublasHandle,cusparseHandle);
	faust_cu_mat<faust_real> const faust_product(tmp);
	faust_cu_mat<faust_real> error(faust_product);	
	error-=data_matrix;	
	faust_real relative_error = error.norm()/data_matrix.norm();
	
	std::cout<<std::endl;	
		std::cout<<"**************** RELATIVE ERROR BETWEEN FAUST AND DATA MATRIX **************** "<<std::endl;
		std::cout<<"		"<<relative_error<<std::endl<<std::endl;
	



	//time comparison between matrix vector product and faust-vector product
	int niter_time_comp = 100;
	if (niter_time_comp > 0)
	{

		faust_cu_timer tdense;
		faust_cu_timer tfaust;
		faust_cu_vec<faust_real> x(data_matrix.getNbCol());
		faust_cu_vec<faust_real> ydense(data_matrix.getNbRow());
		faust_cu_vec<faust_real> yfaust(hier_fact_core.getNbRow());
		faust_cu_vec<faust_real> ycomp(faust_product.getNbRow());

		x.setOnes();


		for (int i=0;i<niter_time_comp;i++)
		{
			
			

			tdense.start();
				gemv(data_matrix,x,ydense,'N',cublasHandle);
			tdense.stop();

				gemv(faust_product,x,ycomp,'N',cublasHandle);				

	 		tfaust.start();
				hier_fact_core.mult(x,yfaust,cusparseHandle);
			tfaust.stop();
			if(!yfaust.equality(ycomp))
			{
				cout<<"ycomp"<<std::endl<<std::endl;								
				yfaust.Display();
				cout<<std::endl<<std::endl<<"yfaust"<<std::endl;
				ycomp.Display();
				cerr << "vector multiplication issue : yfaust (multiplication by faust) and ycomp (multiplication by the dense matrix representing the faust)  are not equal with the given precision"<<epsilon<< endl;					
				exit(EXIT_FAILURE);
			}	

	 	}
		
		
		std::cout<<std::endl;
	

		std::cout<<"**************** TIME COMPARISON MATRIX VECTOR PRODUCT **************** "<<std::endl;
		std::cout<<"	TIME  SPEED-UP : "<<tdense.get_time()/tfaust.get_time()<<std::endl;
		std::cout<<"	MEAN TIME dense : "<<tdense.get_time()/((float) niter_time_comp)<<std::endl;
		std::cout<<"	MEAN TIME faust : "<<tfaust.get_time()/((float) niter_time_comp)<<std::endl;
	}	





	cusparseDestroy(cusparseHandle);
	cublasDestroy(cublasHandle);


	return 0;
}
