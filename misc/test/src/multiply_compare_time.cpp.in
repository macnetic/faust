#include "faust_Transform.h"
#include "faust_init_from_matio_core.h"
#include "faust_init_from_matio_mat.h"
#include "faust_Timer.h"
#include "faust_linear_algebra.h"
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <string>
#include <sstream>
#include <iomanip>



/** \brief Use this script to make runtime comparison between Faust-vector product and Dense matrix-vector product , this script takes to arguments :
\param inputfile Faust_example.mat where all the Fausts with different Density, Dimensions and number of factor are stored. This input file is generated by test/gen_artificial_faust.m (default input file @FAUST_DATA_MAT_DIR@/Faust_example.mat)
\param NB_run the number multiplication made per given configuration (dimension, number of factor, RCG) (default value 100)

The different computed times are stored in a single mat file :
\output matfile @FAUST_TESTOUTPUT_BIN_DIR@/multiply_compare_time.mat
*		all the different computed times are stored in this single mat file into several variables
*		tdense : 4D array where all the dense time multiplication are stored
		tfaust : 4D array where all the faust time multiplication are stored
		DIMS : vector listing all the different dimension that are stored
		RCGS : vector listing all the different (Ratio Complexity Gain (theoritical speed-up for faust multiplication))
		NB_FACTS : vector listing all the different number of factor for a each configuration of faust
		NB_RUN : number, the number of multiplication per configuration

*/

using namespace std;
typedef @TEST_FPP@ FPP;

int main(int argc, char* argv[])
{





	string mat_file = "@FAUST_DATA_MAT_DIR@/Faust_example.mat";// default file input where the faust and the dense matrix are stored
	int nb_run_tmp = 200;// default number of multiplication per configuration of faust



	if (argc >=2)
	{
		string mat_file(argv[1]);

	}
	if (argc >=3)
	{
		nb_run_tmp=atoi(argv[2]);

	}

	/// test upon the coherence of the input filename
	size_t ind = mat_file.find_last_of(".");

	if(ind<=0 || ind>= mat_file.size())
	{
		cerr << "incorrect filename" << endl;
		exit(EXIT_FAILURE);
	}
	string mat_file_extension(mat_file, ind);
	if(mat_file_extension.compare(".mat") != 0)
	{
		cerr << "incorrect filename : extension must be  \".mat\"" << endl;
		exit(EXIT_FAILURE);
	}


	string mat_file_body_tmp(mat_file, 0, ind);


	string mat_file_body_dir, mat_file_body_file;

	ind = mat_file_body_tmp.find_last_of("/");
	if(ind<=0 || ind>= mat_file_body_tmp.size())
	{
		mat_file_body_dir = string("");
		mat_file_body_file = mat_file_body_tmp;
	}
	else
	{
		mat_file_body_dir = string(mat_file_body_tmp, 0, ind+1);
		mat_file_body_file = string(mat_file_body_tmp, ind+1);
	}








	const int NB_RUN = nb_run_tmp;

	int nb_fact;
	int RCG;
	int DIM;


	// initialisation of the different parameter of the test (DIMS,RCGS,NB_FACTS)
	Faust::MatDense<FPP,Cpu> DIMS;
	Faust::MatDense<FPP,Cpu> RCGS;
	Faust::MatDense<FPP,Cpu> NB_FACTS;
	Faust::MatDense<FPP,Cpu> Dense_mat;
	Faust::Transform<FPP,Cpu> fc;
	Faust::MatDense<FPP,Cpu> NB_RUN_MAT(1,1);
	NB_RUN_MAT[0]=NB_RUN;


	init_faust_mat_from_matio(DIMS,mat_file.c_str(),"Dims");
	init_faust_mat_from_matio(RCGS,mat_file.c_str(),"RCGs");
	init_faust_mat_from_matio(NB_FACTS,mat_file.c_str(),"nb_facts");





	DIMS.Display();
	RCGS.Display();

	int nDIMS=DIMS.getNbRow()*DIMS.getNbCol();
	int nRCGS=RCGS.getNbRow()*RCGS.getNbCol();
	int nNB_FACTS=NB_FACTS.getNbRow()*NB_FACTS.getNbCol();

	vector<Faust::MatDense<FPP,Cpu> > Dense_matS(nDIMS);
	//Faust::Transform<FPP,Cpu> FcoreS[nNB_FACTS][nRCGS][nDIMS];
	vector<Faust::Transform<FPP,Cpu> > FcoreS(nNB_FACTS*nRCGS*nDIMS);
	stringstream ssInputVarFaust;
	stringstream ssInputVarDense;
	string OuputDir="@FAUST_TESTOUTPUT_BIN_DIR@/";


	cout << "loading of dense matrix and faust" << endl;

	for (int n=0;n<nNB_FACTS;n++)
	{
		nb_fact = NB_FACTS[n];
		cout<<"  NB_FACT : "<<nb_fact<<endl;
		for (int j=0;j<nDIMS;j++)
		{


			DIM = DIMS[j];
			cout<<"  DIM : "<<DIM<<endl;
			ssInputVarDense.str("");
			ssInputVarDense<<"DMat_Dim_"<<DIM;
			init_faust_mat_from_matio(Dense_mat,mat_file.c_str(),ssInputVarDense.str().c_str());

			Dense_matS[j]=Dense_mat;

			cout<<"      RCG : ";
			for (int i=0;i<nRCGS;i++)
			{
				RCG = RCGS[i];
				cout<<RCG<<" ";
				ssInputVarFaust.str("");
				ssInputVarFaust<<"Faust_nfact_"<<nb_fact<<"_RCG_"<<RCG<<"_Dim_"<<DIM;
				//init_faust_core_from_matiofile(Faust::Transform& core, const char* fileName, const char* variableName)
				init_faust_core_from_matiofile(fc,mat_file.c_str(),ssInputVarFaust.str().c_str());
				//FcoreS[k][i][j]=fc;
				FcoreS[n+i*nNB_FACTS+j*(nNB_FACTS*nRCGS)]=fc;
			}
			cout<<endl;
		}
	}
	cout<<endl<<endl<<endl;




	// this 2 matrix store the different time performance
        // (but represent a 4D array with :
	// 1st dimension corresponding to the NB_RUN,
	// 2nd dimension corresponding to the RCGS (theoretical speed-up),
	// 3rd dimension corresponding to the DIMENSION of the matrix,
	// 4th dimension corresponding to the number of factor a the faust
	Faust::MatDense<float,Cpu> t_dense(NB_RUN*nRCGS,nDIMS*nNB_FACTS);
	Faust::MatDense<float,Cpu> t_faust(NB_RUN*nRCGS,nDIMS*nNB_FACTS);

	Faust::Timer timer_faust;
	Faust::Timer timer_dense;




	cout << "calculus computing" << endl;
	Faust::Vect<FPP,Cpu> x_tmp(Dense_matS[0].getNbCol());
	for (int j=0 ; j<x_tmp.size() ;j++)
		x_tmp[j] = std::rand()*2.0/RAND_MAX-1.0;
	Faust::Vect<FPP,Cpu> y_dense_tmp(Dense_matS[0].getNbRow());
	y_dense_tmp = Dense_matS[0] * x_tmp;
	for (int k=0;k<NB_RUN;k++)
	{
		cout<<"RUN "<<k<<endl;
		for (int n=0;n<nNB_FACTS;n++)
		{

			for (int i=0;i<nRCGS;i++)
			{
				RCG = RCGS[i];
				for (int j=0;j<nDIMS;j++)
				{
					DIM = DIMS[j];
					Faust::Vect<FPP,Cpu> x(DIM);
					Dense_mat = Dense_matS[j];
					//Faust::Transform<FPP,Cpu> fc1(FcoreS[n][i][j]);
					Faust::Transform<FPP,Cpu> fc1(FcoreS[n+i*nNB_FACTS+j*(nNB_FACTS*nRCGS)]);					
					for (int ii=0;ii<DIM;ii++)x[ii]=std::rand()*2.0/RAND_MAX-1;
					Faust::Vect<FPP,Cpu> y_dense(DIM);
					Faust::Vect<FPP,Cpu> y_faust(DIM);

					timer_dense.reset();
					timer_dense.start();
					y_dense = Dense_mat * x;
					timer_dense.stop();

					timer_faust.reset();
					timer_faust.start();
					y_faust = fc1 * x;
					timer_faust.stop();


					t_faust.getData()[(k+i*NB_RUN)+(NB_RUN*nRCGS)*(j+nDIMS*n)]=timer_faust.get_time();
					t_dense.getData()[(k+i*NB_RUN)+(NB_RUN*nRCGS)*(j+nDIMS*n)]=timer_dense.get_time();

				}
			}
		}
	}


	stringstream output_mat_file_ss;



	output_mat_file_ss.str("");

	output_mat_file_ss <<OuputDir<<"multiply_compare_time"<<".mat";

	cout << "writing result in output file : "<<output_mat_file_ss.str().c_str() <<endl;

	write_faust_mat_into_matfile(t_dense,output_mat_file_ss.str().c_str(),"tdense");
	write_faust_mat_into_matfile(t_faust,output_mat_file_ss.str().c_str(),"tfaust");
	write_faust_mat_into_matfile(DIMS,output_mat_file_ss.str().c_str(),"DIMS");
	write_faust_mat_into_matfile(RCGS,output_mat_file_ss.str().c_str(),"RCGS");
	write_faust_mat_into_matfile(NB_FACTS,output_mat_file_ss.str().c_str(),"NB_FACTS");
	write_faust_mat_into_matfile(NB_RUN_MAT,output_mat_file_ss.str().c_str(),"NB_RUN");




	return 0;

}
