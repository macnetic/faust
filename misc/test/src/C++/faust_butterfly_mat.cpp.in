#include "faust_TransformHelperButterfly.h"
#include "faust_MatButterfly.h"
#include <cstdio>

typedef @TEST_FPP@ FPP;

using namespace Faust;
using namespace std;

bool verifyVecEq(Vect<FPP, Cpu> refv, Vect<FPP, Cpu> testv, double tol)
{
	auto err = refv;
	err -= testv;
	return err.norm() <= 1e-6;
}


bool verifyMatEq(MatDense<FPP, Cpu> refm, MatDense<FPP, Cpu> testm, double tol)
{
	auto err = refm;
	err -= testm;
	return err.norm() <= 1e-6;
}

void testClone(MatButterfly<FPP, Cpu>& butterflyMat)
{
	auto size = butterflyMat.getNbRow();
	auto clone = butterflyMat.Clone();
	auto X = MatDense<FPP, Cpu>::randMat(size, size);
	MatDense<FPP, Cpu> refY_(*X);
	MatDense<FPP, Cpu> testY_(*X);

	butterflyMat.multiply(refY_, 'N');
	clone->multiply(testY_, 'N');

	assert(verifyMatEq(refY_, testY_, 1e-6));

	std::cout << "MatButterfly cloning OK" << std::endl;
	delete X;
	delete clone;
}

void testTranspose(MatButterfly<FPP, Cpu>& butterflyMat, MatSparse<FPP, Cpu>& spButterflyMat)
{
	auto size = butterflyMat.getNbRow();
	MatSparse<FPP, Cpu> trefsp(spButterflyMat);
	MatButterfly<FPP, Cpu> ttest(butterflyMat);

	auto X = MatDense<FPP, Cpu>::randMat(size, size);

	trefsp.transpose();
	ttest.transpose();

	MatDense<FPP, Cpu> refY_(*X);
	MatDense<FPP, Cpu> testY_(*X);

	trefsp.multiply(refY_, 'N');
	ttest.multiply(testY_, 'N');

	auto errY_ = testY_;
	errY_ -= refY_;
	assert(errY_.norm() <= 1e-6);

	// test transpose of transpose
	trefsp.transpose();
	ttest.transpose();

	refY_ = *X;
	testY_ = *X;

	trefsp.multiply(refY_, 'N');
	ttest.multiply(testY_, 'N');

	errY_ = testY_;
	errY_ -= refY_;
	assert(errY_.norm() <= 1e-6);

	// test mul of transpose by a vector
	Vect<FPP, Cpu> refy(X->getNbRow(), X->getData());
	Vect<FPP, Cpu> testy(X->getNbRow(), X->getData());

	trefsp.transpose();
	ttest.transpose();

	trefsp.multiply(refy, 'N');
	ttest.multiply(testy, 'N');

	auto erry = refy;
	erry -= testy;
	assert(erry.norm() <= 1e-6);

	// test mul of transpose of transpose by a vector
	Vect<FPP, Cpu> refy2(X->getNbRow(), X->getData());
	Vect<FPP, Cpu> testy2(X->getNbRow(), X->getData());

	trefsp.transpose();
	ttest.transpose();

	trefsp.multiply(refy2, 'N');
	ttest.multiply(testy2, 'N');

	erry = refy2;
	erry -= testy2;
	assert(erry.norm() <= 1e-6);

	delete X;


	std::cout << "MatButterfly transpose OK" << std::endl;
}

void testNNZSize(MatButterfly<FPP, Cpu>& butterflyMat, MatSparse<FPP, Cpu>& spButterflyMat)
{

	assert(butterflyMat.getNonZeros() == spButterflyMat.getNonZeros());
//	cout << "nbytes sp, butter:" << spButterflyMat.getNBytes() << " " << butterflyMat.getNBytes()  << endl;
	assert(butterflyMat.getNBytes() == (butterflyMat.getNbRow() * (2 * sizeof(FPP) + sizeof(int))));
	MatButterfly<FPP, Cpu> tbutterflyMat(butterflyMat);
	tbutterflyMat.transpose();
//	cout << "nbytes sp, tbutter:" << spButterflyMat.getNBytes() << " " << tbutterflyMat.getNBytes()  << endl;
	assert(tbutterflyMat.getNBytes() == (tbutterflyMat.getNbRow() * (3 * sizeof(FPP) + sizeof(int))));
	std::cout << "MatButterfly getNonZeros() and getNBytes() OK" << std::endl;
}

void testType(MatButterfly<FPP, Cpu>& butterflyMat)
{
	assert(butterflyMat.getType() == Butterfly);
	std::cout << "MatButterfly getType() OK" << std::endl;
}

void testScalMul(const MatButterfly<FPP, Cpu>& butterflyMat,  const MatSparse<FPP, Cpu>& spButterflyMat)
{

	auto size = spButterflyMat.getNbRow();
	auto X = MatDense<FPP, Cpu>::randMat(size, size);
	auto alpha = FPP(2.0);

	MatButterfly<FPP, Cpu> mButterflyMat(butterflyMat);
	MatSparse<FPP, Cpu> mspButterflyMat(spButterflyMat);

	mButterflyMat *= alpha;
	mspButterflyMat *= alpha;

	Vect<FPP, Cpu> refy(X->getNbRow(), X->getData());
	Vect<FPP, Cpu> testy(X->getNbRow(), X->getData());

	mButterflyMat.multiply(refy, 'N');
	mspButterflyMat.multiply(testy, 'N');

	assert(verifyVecEq(refy, testy, 1e-6));

	delete X;

	std::cout << "MatButterfly scal. mul OK" << std::endl;
}

void testNorm2(const MatButterfly<FPP, Cpu>& butterflyMat,  const MatSparse<FPP, Cpu>& spButterflyMat)
{
//	cout << butterflyMat.norm()  << endl;
//	cout << spButterflyMat.norm()  << endl;
	assert(std::abs(butterflyMat.norm() - spButterflyMat.norm()) < 1e-6);
	std::cout << "MatButterfly fro-norm OK" << std::endl;
}

void testToMatSparse(const MatButterfly<FPP, Cpu>& butterflyMat,  const MatSparse<FPP, Cpu>& spButterflyMat)
{
	auto convSpButterflyMat = butterflyMat.toMatSparse();

	assert(verifyMatEq(MatDense<FPP, Cpu>(convSpButterflyMat), MatDense<FPP, Cpu>(spButterflyMat), 1e-6));

	std::cout << "MatButterfly::toMatSparse OK" << std::endl;
}

int main(int argc, char** argv)
{
	int log2size = 4;
	if(argc > 1)
		log2size = std::atoi(argv[1]);
	std::cout << "log2size: " << log2size << std::endl;

	int size = 1 << log2size;
	auto F = TransformHelper<FPP, Cpu>::fourierFaust(log2size, false);
	auto dsButterflyMat = F->get_fact(0);
	MatSparse<FPP, Cpu> spButterflyMat(dsButterflyMat);
	MatButterfly<FPP, Cpu> butterflyMat(spButterflyMat, /* level */ 0);

	Vect<FPP, Cpu> x(size);
	x.setRand();
	const Vect<FPP, Cpu> x_(x);
//	x.setOnes();

	Vect<FPP, Cpu> ref_v = spButterflyMat.multiply(x_);
	Vect<FPP, Cpu> test_v = butterflyMat.multiply(x_);

	ref_v.Display();
	test_v.Display();
	auto err = test_v;
	err -= ref_v;
	assert(err.norm() <= 1e-6);
	std::cout << "butterfly-vector product OK" << std::endl;


	// test multiplying a MatDense
	auto X = MatDense<FPP, Cpu>::randMat(size, size);
	MatDense<FPP, Cpu> refY(*X);
	MatDense<FPP, Cpu> testY(*X);

	spButterflyMat.multiply(refY, 'N');
	butterflyMat.multiply(testY, 'N');

	auto errY = testY;
	errY -= refY;
	assert(errY.norm() <= 1e-6);

	std::cout << "Faust-dense matrix product OK" << std::endl;

	// test multiplying a MatSparse
	auto spX = MatSparse<FPP, Cpu>::randMat(size, size, .2);
	MatSparse<FPP, Cpu> refYsp(*spX);
	MatSparse<FPP, Cpu> testYsp(*spX);
	//	 X->setOnes();

	spButterflyMat.multiply(refYsp, 'N');
	butterflyMat.multiply(testYsp, 'N');

	MatDense<FPP, Cpu> errYsp = testYsp;
	errYsp -= refYsp;
	assert(errYsp.norm() <= 1e-6);

	std::cout << "Faust-sparse matrix product OK" << std::endl;

	testClone(butterflyMat);

	testTranspose(butterflyMat, spButterflyMat);
	testNNZSize(butterflyMat, spButterflyMat);
	testType(butterflyMat);

	testScalMul(butterflyMat, spButterflyMat);
	testNorm2(butterflyMat, spButterflyMat);
	testToMatSparse(butterflyMat, spButterflyMat);
	return EXIT_SUCCESS;
}
