#include "faust_constant.h"
#include "faust_MatDense.h"
#include "faust_MatSparse.h"
#include "faust_MatBSR.h"
#include <cstdlib>
#include <algorithm>


typedef @TEST_FPP@ FPP;

using namespace std;
using namespace Faust;

void test_fro_norm(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::norm:" << std::endl;
	auto dmat = bmat.to_dense();
	cout << "bsr mat fro-norm:" << bmat.norm() << std::endl;
	cout << "dense mat fro-norm:" << dmat.norm() << std::endl;
	assert(std::abs(bmat.norm()-dmat.norm()) < 1e-6);
	cout << "OK." << std::endl;
}

void test_1_norm(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::normL1:" << std::endl;
	auto dmat = bmat.to_dense();
	cout << "bsr mat fro-normL1:" << bmat.normL1() << std::endl;
	cout << "dense mat fro-normL1:" << dmat.normL1() << std::endl;
	assert(std::abs(bmat.normL1()-dmat.normL1()) < 1e-6);
	cout << "OK." << std::endl;
}

void test_clone(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::clone" << endl;
	auto clone = bmat.Clone();
	cout << "bsr mat fro-norm:" << bmat.norm() << std::endl;
	cout << "clone bsr mat fro-norm:" << clone->norm() << std::endl;
	assert(std::abs(bmat.norm()-clone->norm()) < 1e-6);
	cout << "OK" << std::endl;
}

void test_mul_vec(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(Vect)" << endl;
	auto md = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 1);
	Vect<FPP, Cpu> vec(bmat.getNbCol(), md->getData());
	Vect<FPP, Cpu> vec_cpy(bmat.getNbCol(), md->getData());
	auto dmat = bmat.to_dense();
	bmat.multiply(vec, 'N');
	dmat.multiply(vec_cpy, 'N');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	cout << "MatBSR::multiply(Vect, 'N') OK" << endl;
	bmat.multiply(vec, 'T');
	dmat.multiply(vec_cpy, 'T');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	cout << "MatBSR::multiply(Vect, 'T') OK" << endl;
	bmat.multiply(vec, 'H');
	dmat.multiply(vec_cpy, 'H');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	delete md;
	cout << "OK" << endl;
}

void test_mul_vec2(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing Vect MatBSR::multiply(Vect)" << endl;
	auto md = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 1);
	Vect<FPP, Cpu> vec(bmat.getNbCol(), md->getData());
	auto dmat = bmat.to_dense();
	Vect<FPP, Cpu> test_vec = bmat.multiply(vec);
	Vect<FPP, Cpu> ref_vect = dmat.multiply(vec);
	assert(std::abs(test_vec.norm()-ref_vect.norm()) < 1e-6);
	delete md;
	cout << "OK" << endl;
}

void test_mul_dense(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'N');
	bmat.multiply(rmd_copy, 'N');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_dense_transp(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense, T)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'T');
	bmat.multiply(rmd_copy, 'T');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_dense_transconj(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense, H)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'H');
	bmat.multiply(rmd_copy, 'H');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, N)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	std::cout << "sp has nan:" << rms.containsNaN() << std::endl;
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'N');
	bmat.multiply(rms_copy, 'N');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_transp(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, T)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'T');
	bmat.multiply(rms_copy, 'T');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_transconj(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, H)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'H');
	bmat.multiply(rms_copy, 'H');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_right(const MatBSR<FPP, Cpu>& bmat_orig)
{
	cout << "=== Testing MatBSR::multiplyRight(MatSparse)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat_orig.getNbCol(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	auto dmat = bmat_orig.to_dense();
	MatBSR<FPP, Cpu> bmat(bmat_orig);
	dmat.multiplyRight(rms);
	bmat.multiplyRight(rms);
	auto dmat_copy = bmat.to_dense();
//	dmat.Display();
//	bmat.Display();
	assert(bmat.getNbRow() == dmat.getNbRow() && bmat.getNbCol() == dmat.getNbCol());
	dmat -= dmat_copy;
	assert(dmat.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_gemm_NN(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmNN" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'N', 'N');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'N', 'N');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_NT(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmNT" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbCol());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	std::cout << "ds has nan:" << B->containsNaN() << std::endl;
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'N', 'T');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'N', 'T');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_TT(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmTT" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbRow());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'T', 'T');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'T', 'T');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_HH(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmHH" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbRow());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'H', 'H');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'H', 'H');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_transpose(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::transpose" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_t = bmat;
	bmat.to_dense().print_file("bmat.txt");
	bmat_t.transpose();
	dmat.transpose();
	assert(bmat_t.getNbRow() == dmat.getNbRow() && bmat_t.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_t.to_dense();
	test -= dmat;
	dmat.print_file("dmat.txt");
	bmat_t.to_dense().print_file("bmat_t.txt");
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_conjugate(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::conjugate" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_c = bmat;
	bmat_c.conjugate();
	dmat.conjugate();
	assert(bmat_c.getNbRow() == dmat.getNbRow() && bmat_c.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_c.to_dense();
	test -= dmat;
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_adjoint(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::adjoint" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_a = bmat;
	bmat_a.adjoint();
	dmat.adjoint();
	assert(bmat_a.getNbRow() == dmat.getNbRow() && bmat_a.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_a.to_dense();
	test -= dmat;
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_nnz(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getNonZeros" << endl;
	auto dmat = bmat.to_dense();
	assert(bmat.getNonZeros() == dmat.getNonZeros());
	cout << "OK" << endl;
}

void test_nbytes(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getNBytes" << endl;
	auto dmat = bmat.to_dense();
	assert(bmat.getNBytes() == bmat.getNBlocks()*bmat.getNbBlockRow()*bmat.getNbBlockCol()*sizeof(FPP)+(bmat.getNbBlocksPerDim(0)+1+bmat.getNBlocks())*sizeof(int));
	cout << "OK" << endl;
}

void test_get_type(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getType" << endl;
	assert(bmat.getType() == BSR);
	cout << "OK" << endl;
}

void test_mul_scal(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::operator*=(FPP)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatBSR<FPP, Cpu> bmat_copy(bmat);
	auto dmat = bmat.to_dense();
	FPP scal = (*rmd)(0,0);
	dmat *= scal;
	bmat_copy *= scal;
	MatDense<FPP, Cpu> test(dmat);
	test -= bmat_copy.to_dense();
	assert(test.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_get_col(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_col" << endl;
	int n = bmat.getNbRow();
	Vect<FPP, Cpu> bcol(n);
	Vect<FPP, Cpu> dcol(n);
	Vect<FPP, Cpu> test(n);
	auto dmat = bmat.to_dense();
	for(int j=0;j<bmat.getNbCol(); j++)
	{
		dcol = dmat.get_col(j);
		bcol = bmat.get_col(j);
		test = dcol;
		test -= bcol;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}


void test_get_cols(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_cols(faust_unsigned_int, faust_unsigned_int)" << endl;
	int n = bmat.getNbRow();
	MatDense<FPP, Cpu> test;
	auto dmat = bmat.to_dense();
	for(int j=0;j<bmat.getNbCol()-1; j++)
	{
		auto ncols = bmat.getNbCol()-j;
		auto dcols = dmat.get_cols(j, ncols);
		auto bcols = bmat.get_cols(j, ncols);
//		bcols->Display();
//		dcols->Display();
		assert(dcols->getNbCol() == bcols->getNbCol());
		assert(dcols->getNbRow() == bcols->getNbRow());
//		cout << bcols->norm() << " " << dcols->norm() << endl;
		test = *dcols;
		test -= MatDense<FPP, Cpu>(*bcols);
		delete dcols;
		delete bcols;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}

void test_get_rows(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_rows(faust_unsigned_int, faust_unsigned_int)" << endl;
	int n = bmat.getNbRow();
	MatDense<FPP, Cpu> test;
	auto dmat = bmat.to_dense();
	for(int i=0;i<bmat.getNbRow()-1; i++)
	{
		auto nrows = bmat.getNbRow()-i;
		auto drows = dmat.get_rows(i, nrows);
		auto brows = bmat.get_rows(i, nrows);
//		brows->Display();
//		drows->Display();
		assert(drows->getNbCol() == brows->getNbCol());
		assert(drows->getNbRow() == brows->getNbRow());
//		cout << brows->norm() << " " << drows->norm() << endl;
		test = *drows;
		test -= MatDense<FPP, Cpu>(*brows);
		delete drows;
		delete brows;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}

void test_get_cols2(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_cols(faust_unsigned_int, faust_unsigned_int)" << endl;
	int n = bmat.getNbRow();
	MatDense<FPP, Cpu> test;
	auto dmat = bmat.to_dense();
	for(int j=0;j<bmat.getNbCol()-1; j++)
	{
		unsigned int ncols = bmat.getNbCol()-j;
		auto col_ids = new unsigned long int[ncols];
		for(int k=0;k<ncols;k++)
			col_ids[k] = rand()*(ncols-1)/RAND_MAX;
		auto dcols = dmat.get_cols(col_ids, ncols);
		auto bcols = bmat.get_cols(col_ids, ncols);
//		bcols->Display();
//		dcols->Display();
		assert(dcols->getNbCol() == bcols->getNbCol());
		assert(dcols->getNbRow() == bcols->getNbRow());
//		cout << bcols->norm() << " " << dcols->norm() << endl;
		test = *dcols;
		test -= MatDense<FPP, Cpu>(*bcols);
		delete dcols;
		delete bcols;
		delete []col_ids;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}

void test_get_rows2(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_rows(faust_unsigned_int, faust_unsigned_int)" << endl;
	int n = bmat.getNbRow();
	MatDense<FPP, Cpu> test;
	auto dmat = bmat.to_dense();
	for(int i=0;i<bmat.getNbRow()-1; i++)
	{
		unsigned int nrows = bmat.getNbRow()-i;
		auto row_ids = new unsigned long int[nrows];
		for(int k=0;k<nrows;k++)
			row_ids[k] = rand()*(nrows-1)/RAND_MAX;
		auto drows = dmat.get_rows(row_ids, nrows);
		auto brows = bmat.get_rows(row_ids, nrows);
//		brows->Display();
//		drows->Display();
		assert(drows->getNbCol() == brows->getNbCol());
		assert(drows->getNbRow() == brows->getNbRow());
//		cout << brows->norm() << " " << drows->norm() << endl;
		test = *drows;
		test -= MatDense<FPP, Cpu>(*brows);
		delete drows;
		delete brows;
		delete []row_ids;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}

void test_nonzero_indices(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::nonzeros_indices" << endl;
	MatDense<FPP, Cpu> dmat = bmat.to_dense();
	auto dnzi = dmat.nonzeros_indices();
	auto bnzi = bmat.nonzeros_indices();
	for(auto p: dnzi)
	{
		assert(find(begin(bnzi), end(bnzi), p) != end(bnzi));
	}
	assert(bnzi.size() == dnzi.size());
	cout << "OK" << endl;
}

void test_set_zeros(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::nonzeros_indices" << endl;
	MatBSR<FPP, Cpu> bmat_z(bmat);
	assert(bmat_z.norm() != FPP(0));
	bmat_z.setZeros();
	assert(bmat_z.norm() == FPP(0));
	cout << "OK" << endl;
}


void test_has_nan(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::containsNaN" << endl;
	assert(!bmat.containsNaN());
	// generate a randome MatBSR and put a NaN in data
	auto browptr = new int[bmat.getNbBlocksPerDim(0)+1];
	browptr[0] = 0;
	for(int i=1;i<bmat.getNbBlocksPerDim(0)+1;i++)
	{
		auto nblocks = rand()*(bmat.getNbBlocksPerDim(1))/RAND_MAX;
		browptr[i] = browptr[i-1] + nblocks;
	}
	auto nblocks = browptr[bmat.getNbBlocksPerDim(0)];
	auto bcolinds = new int[nblocks];
	auto data = new FPP[nblocks];
	for(int i=0;i<nblocks;i++)
	{
		bcolinds[i] = rand()*(bmat.getNbBlocksPerDim(1)-1)/RAND_MAX;
		for(int bi=0;bi<bmat.getNbBlocksPerDim(0);bi++)
			for(int bj=0;bj<bmat.getNbBlocksPerDim(1);bj++)
			{
				data[i*bmat.getNbBlockRow()*bmat.getNbBlockCol()+bj*bmat.getNbBlockRow()+bi] = FPP(rand());
			}
	}
	data[0] = FPP(NAN);
	cout << data[0] << std::endl;
	MatBSR<FPP, Cpu> bmat_copy(bmat.getNbRow(), bmat.getNbCol(), bmat.getNbBlockRow(), bmat.getNbBlockCol(), bmat.getNBlocks(), data, browptr, bcolinds);
	assert(bmat_copy.containsNaN());
	delete[] browptr;
	delete[] bcolinds;
	delete[] data;
	cout << "OK" << endl;
}

void test_getitem(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::operator(int,int)" << endl;
	auto dmat = bmat.to_dense();
	for(int i=0;i < bmat.getNbRow();i++)
	{
		for(int j=0;j < bmat.getNbCol();j++)
		{
			assert(dmat(i,j) == bmat(i,j));
		}
	}
	cout << "OK" << endl;
}

void test_tosparse(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::to_sparse" << endl;
	auto smat = bmat.to_sparse();
	MatDense<FPP, Cpu> test(smat);
	auto dmat = bmat.to_dense();
	test -= dmat;
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

int main(int argc, char** argv)
{
	int m, n, bm, bn, bnnz;
	srand(time(NULL));
	m = 10;
	n = 10;
	bm = 2;
	bn = 2;
	bnnz = 8;
	auto bmat = MatBSR<FPP, Cpu>::randMat(m, n, bm, bn, bnnz);
	bmat->Display();
	test_fro_norm(*bmat);
	test_1_norm(*bmat);
	test_clone(*bmat);
	test_mul_vec(*bmat);
	test_mul_vec2(*bmat);
	test_mul_dense(*bmat);
	test_mul_dense_transp(*bmat);
	test_mul_dense_transconj(*bmat);
	test_mul_sparse(*bmat);
	test_mul_sparse_transp(*bmat);
	test_mul_sparse_transconj(*bmat);
	test_mul_sparse_right(*bmat);
	test_gemm_NN(*bmat);
	test_gemm_NT(*bmat);
	test_gemm_TT(*bmat);
	test_gemm_HH(*bmat);
	test_transpose(*bmat);
	test_conjugate(*bmat);
	test_adjoint(*bmat);
	test_nnz(*bmat);
	test_nbytes(*bmat);
	test_get_type(*bmat);
	test_mul_scal(*bmat);
	test_get_col(*bmat);
	test_get_cols(*bmat);
	test_get_rows(*bmat);
	test_get_cols2(*bmat);
	test_get_rows2(*bmat);
	test_nonzero_indices(*bmat);
	test_set_zeros(*bmat);
//	test_has_nan(*bmat);
	test_getitem(*bmat);
	test_tosparse(*bmat);
	delete bmat;
	return EXIT_SUCCESS;
}


