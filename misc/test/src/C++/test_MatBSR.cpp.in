#include "faust_constant.h"
#include "faust_MatDense.h"
#include "faust_MatSparse.h"
#include "faust_MatBSR.h"


typedef @TEST_FPP@ FPP;

using namespace std;
using namespace Faust;

void test_fro_norm(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::norm:" << std::endl;
	auto dmat = bmat.to_dense();
	cout << "bsr mat fro-norm:" << bmat.norm() << std::endl;
	cout << "dense mat fro-norm:" << dmat.norm() << std::endl;
	assert(std::abs(bmat.norm()-dmat.norm()) < 1e-6);
	cout << "OK." << std::endl;
}

void test_1_norm(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::normL1:" << std::endl;
	auto dmat = bmat.to_dense();
	cout << "bsr mat fro-normL1:" << bmat.normL1() << std::endl;
	cout << "dense mat fro-normL1:" << dmat.normL1() << std::endl;
	assert(std::abs(bmat.normL1()-dmat.normL1()) < 1e-6);
	cout << "OK." << std::endl;
}

void test_clone(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::clone" << endl;
	auto clone = bmat.Clone();
	cout << "bsr mat fro-norm:" << bmat.norm() << std::endl;
	cout << "clone bsr mat fro-norm:" << clone->norm() << std::endl;
	assert(std::abs(bmat.norm()-clone->norm()) < 1e-6);
	cout << "OK" << std::endl;
}

void test_mul_vec(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(Vect)" << endl;
	auto md = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 1);
	Vect<FPP, Cpu> vec(bmat.getNbCol(), md->getData());
	Vect<FPP, Cpu> vec_cpy(bmat.getNbCol(), md->getData());
	auto dmat = bmat.to_dense();
	bmat.multiply(vec, 'N');
	dmat.multiply(vec_cpy, 'N');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	cout << "MatBSR::multiply(Vect, 'N') OK" << endl;
	bmat.multiply(vec, 'T');
	dmat.multiply(vec_cpy, 'T');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	cout << "MatBSR::multiply(Vect, 'T') OK" << endl;
	bmat.multiply(vec, 'H');
	dmat.multiply(vec_cpy, 'H');
//	cout << "ref vec:";vec_cpy.Display(); cout << "norm: " << vec_cpy.norm() << std::endl;
//	cout << "test vec:";vec.Display(); cout << "norm: " << vec.norm() << std::endl;
	assert(std::abs(vec.norm()-vec_cpy.norm()) < 1e-6);
	delete md;
	cout << "OK" << endl;
}

void test_mul_vec2(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing Vect MatBSR::multiply(Vect)" << endl;
	auto md = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 1);
	Vect<FPP, Cpu> vec(bmat.getNbCol(), md->getData());
	auto dmat = bmat.to_dense();
	Vect<FPP, Cpu> test_vec = bmat.multiply(vec);
	Vect<FPP, Cpu> ref_vect = dmat.multiply(vec);
	assert(std::abs(test_vec.norm()-ref_vect.norm()) < 1e-6);
	delete md;
	cout << "OK" << endl;
}

void test_mul_dense(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'N');
	bmat.multiply(rmd_copy, 'N');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_dense_transp(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense, T)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'T');
	bmat.multiply(rmd_copy, 'T');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_dense_transconj(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatDense, H)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> rmd_copy(*rmd);
	auto dmat = bmat.to_dense();
	dmat.multiply(*rmd, 'H');
	bmat.multiply(rmd_copy, 'H');
	assert((*rmd).getNbRow() == rmd_copy.getNbRow() && (*rmd).getNbCol() == rmd_copy.getNbCol());
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, N)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	std::cout << "sp has nan:" << rms.containsNaN() << std::endl;
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'N');
	bmat.multiply(rms_copy, 'N');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_transp(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, T)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'T');
	bmat.multiply(rms_copy, 'T');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_transconj(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::multiply(MatSparse, H)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	MatSparse<FPP, Cpu> rms_copy(rms);
	auto dmat = bmat.to_dense();
	dmat.multiply(rms, 'H');
	bmat.multiply(rms_copy, 'H');
	assert(rms.getNbRow() == rms_copy.getNbRow() && rms.getNbCol() == rms_copy.getNbCol());
	*rmd = rms;
	MatDense<FPP, Cpu> rmd_copy(rms_copy);
	rmd_copy -= *rmd;
	assert(rmd_copy.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_mul_sparse_right(const MatBSR<FPP, Cpu>& bmat_orig)
{
	cout << "=== Testing MatBSR::multiplyRight(MatSparse)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat_orig.getNbCol(), 32);
	MatSparse<FPP, Cpu> rms(*rmd);
	auto dmat = bmat_orig.to_dense();
	MatBSR<FPP, Cpu> bmat(bmat_orig);
	dmat.multiplyRight(rms);
	bmat.multiplyRight(rms);
	auto dmat_copy = bmat.to_dense();
//	dmat.Display();
//	bmat.Display();
	assert(bmat.getNbRow() == dmat.getNbRow() && bmat.getNbCol() == dmat.getNbCol());
	dmat -= dmat_copy;
	assert(dmat.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_gemm_NN(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmNN" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'N', 'N');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'N', 'N');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_NT(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmNT" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbCol());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbRow(), 32);
	std::cout << "ds has nan:" << B->containsNaN() << std::endl;
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'N', 'T');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'N', 'T');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_TT(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmTT" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbRow());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'T', 'T');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'T', 'T');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_gemm_HH(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::faust_gemmHH" << endl;
	auto B = MatDense<FPP, Cpu>::randMat(32, bmat.getNbRow());
	auto C = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatDense<FPP, Cpu> C_copy(*C);
	auto dmat = bmat.to_dense();
	bmat.faust_gemm(*B, *C, (*B)(0,0), (*C)(0,0), 'H', 'H');
	dmat.faust_gemm(*B, C_copy, (*B)(0,0), C_copy(0,0), 'H', 'H');
	MatDense<FPP, Cpu> test = *C;
	test -= C_copy;
	assert(test.norm() < 1e-6);
	delete B;
	delete C;
	cout << "OK" << endl;
}

void test_transpose(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::transpose" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_t = bmat;
	bmat.to_dense().print_file("bmat.txt");
	bmat_t.transpose();
	dmat.transpose();
	assert(bmat_t.getNbRow() == dmat.getNbRow() && bmat_t.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_t.to_dense();
	test -= dmat;
	dmat.print_file("dmat.txt");
	bmat_t.to_dense().print_file("bmat_t.txt");
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_conjugate(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::conjugate" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_c = bmat;
	bmat_c.conjugate();
	dmat.conjugate();
	assert(bmat_c.getNbRow() == dmat.getNbRow() && bmat_c.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_c.to_dense();
	test -= dmat;
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_adjoint(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::adjoint" << endl;
	auto dmat = bmat.to_dense();
	MatBSR<FPP, Cpu> bmat_a = bmat;
	bmat_a.adjoint();
	dmat.adjoint();
	assert(bmat_a.getNbRow() == dmat.getNbRow() && bmat_a.getNbCol() == dmat.getNbCol());
	MatDense<FPP, Cpu> test = bmat_a.to_dense();
	test -= dmat;
	assert(test.norm() < 1e-6);
	cout << "OK" << endl;
}

void test_nnz(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getNonZeros" << endl;
	auto dmat = bmat.to_dense();
	assert(bmat.getNonZeros() == dmat.getNonZeros());
	cout << "OK" << endl;
}

void test_nbytes(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getNBytes" << endl;
	auto dmat = bmat.to_dense();
	assert(bmat.getNBytes() == bmat.getNBlocks()*bmat.getNbBlockRow()*bmat.getNbBlockCol()*sizeof(FPP)+(bmat.getNbBlocksPerDim(0)+1+bmat.getNBlocks())*sizeof(int));
	cout << "OK" << endl;
}

void test_get_type(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::getType" << endl;
	assert(bmat.getType() == BSR);
	cout << "OK" << endl;
}

void test_mul_scal(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::operator*=(FPP)" << endl;
	auto rmd = MatDense<FPP, Cpu>::randMat(bmat.getNbCol(), 32);
	MatBSR<FPP, Cpu> bmat_copy(bmat);
	auto dmat = bmat.to_dense();
	FPP scal = (*rmd)(0,0);
	dmat *= scal;
	bmat_copy *= scal;
	MatDense<FPP, Cpu> test(dmat);
	test -= bmat_copy.to_dense();
	assert(test.norm() < 1e-6);
	delete rmd;
	cout << "OK" << endl;
}

void test_get_col(const MatBSR<FPP, Cpu>& bmat)
{
	cout << "=== Testing MatBSR::get_col" << endl;
	int n = bmat.getNbRow();
	Vect<FPP, Cpu> bcol(n);
	Vect<FPP, Cpu> dcol(n);
	Vect<FPP, Cpu> test(n);
	auto dmat = bmat.to_dense();
	for(int j=0;j<bmat.getNbCol(); j++)
	{
		dcol = dmat.get_col(j);
		bcol = bmat.get_col(j);
		test = dcol;
		test -= bcol;
		assert(test.norm() < 1e-6);
	}
	cout << "OK" << endl;
}

int main(int argc, char** argv)
{
	int m, n, bm, bn, bnnz;
	m = 10;
	n = 10;
	bm = 2;
	bn = 2;
	bnnz = 8;
	auto bmat = MatBSR<FPP, Cpu>::randMat(m, n, bm, bn, bnnz);
	bmat->Display();
	test_fro_norm(*bmat);
	test_1_norm(*bmat);
	test_clone(*bmat);
	test_mul_vec(*bmat);
	test_mul_vec2(*bmat);
	test_mul_dense(*bmat);
	test_mul_dense_transp(*bmat);
	test_mul_dense_transconj(*bmat);
	test_mul_sparse(*bmat);
	test_mul_sparse_transp(*bmat);
	test_mul_sparse_transconj(*bmat);
	test_mul_sparse_right(*bmat);
	test_gemm_NN(*bmat);
	test_gemm_NT(*bmat);
	test_gemm_TT(*bmat);
	test_gemm_HH(*bmat);
	test_transpose(*bmat);
	test_conjugate(*bmat);
	test_adjoint(*bmat);
	test_nnz(*bmat);
	test_nbytes(*bmat);
	test_get_type(*bmat);
	test_mul_scal(*bmat);
	test_get_col(*bmat);
	delete bmat;
	return EXIT_SUCCESS;
}


