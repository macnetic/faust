/****************************************************************************/
/*                              Description:                                */
/*  For more information on the FAuST Project, please visit the website     */
/*  of the project : <http://faust.gforge.inria.fr>                         */
/*                                                                          */
/*                              License:                                    */
/*  Copyright (2016):   Nicolas Bellot, Adrien Leman, Thomas Gautrais,      */
/*                      Luc Le Magoarou, Remi Gribonval                     */
/*                      INRIA Rennes, FRANCE                                */
/*                      http://www.inria.fr/                                */
/*                                                                          */
/*  The FAuST Toolbox is distributed under the terms of the GNU Affero      */
/*  General Public License.                                                 */
/*  This program is free software: you can redistribute it and/or modify    */
/*  it under the terms of the GNU Affero General Public License as          */
/*  published by the Free Software Foundation.                              */
/*                                                                          */
/*  This program is distributed in the hope that it will be useful, but     */
/*  WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                    */
/*  See the GNU Affero General Public License for more details.             */
/*                                                                          */
/*  You should have received a copy of the GNU Affero General Public        */
/*  License along with this program.                                        */
/*  If not, see <http://www.gnu.org/licenses/>.                             */
/*                                                                          */
/*                             Contacts:                                    */
/*      Nicolas Bellot  : nicolas.bellot@inria.fr                           */
/*      Adrien Leman    : adrien.leman@inria.fr                             */
/*      Thomas Gautrais : thomas.gautrais@inria.fr                          */
/*      Luc Le Magoarou : luc.le-magoarou@inria.fr                          */
/*      Remi Gribonval  : remi.gribonval@inria.fr                           */
/*                                                                          */
/*                              References:                                 */
/*  [1] Le Magoarou L. and Gribonval R., "Flexible multi-layer sparse       */
/*  approximations of matrices and applications", Journal of Selected       */
/*  Topics in Signal Processing, 2016.                                      */
/*  <https://hal.archives-ouvertes.fr/hal-01167948v1>                       */
/****************************************************************************/
#include "faust_MatDense_gpu.h"
#include "faust_Transform_gpu.h"
#include "faust_MatSparse_gpu.h"
#include "faust_Vect_gpu.h"
#include "faust_Params.h"
#include "faust_ParamsPalm.h"
#include "faust_StoppingCriterion.h"
#include "faust_init_from_matio_params.h"
#include "faust_init_from_matio_core.h"
#include "faust_Palm4MSA.h"
#include "faust_HierarchicalFact.h"
#include "faust_Timer_gpu.h"
#include "faust_linear_algebra_gpu.h"
#include <iostream>
#include <iomanip>
#include <fstream>
#include "faust_SpBlasHandle_gpu.h"
#include "faust_BlasHandle_gpu.h"

/** \brief An example of using the hierarchical factorization of a dense matrix using GPU process. from .mat file.
* An dense matrix is loaded from "@FAUST_DATA_MAT_DIR@
* \param MatrixFilename :  a .mat (MATLAB file) where the matrix to be factorized is stored
* \param configFilename : a .mat (MATLAB file) configuration file which contains the parameter of the hierarchical algorithm (default launch with a predefined configuration called hierFact)
* \param expectedLambda (optionnal) : compared the expected scalar of the factorisation with the computed one in the precision defined with epsilon
*\param epsilon (optionnal) : precision for the test of equality (default value 0.0001)
*/

using namespace std;
typedef @TEST_FPP@ FPP;//faust floating point precision

int main(int argc, char* argv[])
{
	if (typeid(FPP) == typeid(double))
  	{
		cout<<"floating point precision == double"<<endl;
  	}

  	if (typeid(FPP) == typeid(float))
  	{
		cout<<"floating point precision == float"<<endl;
  	}


	string configFilename = "@FAUST_CONFIG_MAT_DIR@/config_compared_hierarchical_fact.mat";
	string MatrixFilename = "@FAUST_DATA_MAT_DIR@/matrix_hierarchical_fact.mat";

	if (argc >= 3)
	{
		configFilename = argv[2];
		MatrixFilename = argv[1];
	}

	FPP expectedLambda = 0;
	if (argc >= 4)
		expectedLambda = atof(argv[3]);


	FPP epsilon = 0.0001;
	if (argc >= 5)
		epsilon = atof(argv[4]);


	size_t ind = configFilename.find_last_of(".");

	if(ind<=0 || ind>= configFilename.size())
	{
		cerr << "Le nom du fichier est incorrect" << endl;
		exit(EXIT_FAILURE);
	}
	string configFileExtension(configFilename, ind);
	if(configFileExtension.compare(".mat") != 0)
	{
		cerr << "Le nom du fichier doit se terminer par \".mat\"" << endl;
		exit(EXIT_FAILURE);
	}
	string configFileBodyTmp(configFilename, 0, ind);


	string configFileBodyDir, configFileBodyFile;

	ind = configFileBodyTmp.find_last_of("/");
	if(ind<=0 || ind>= configFileBodyTmp.size())
	{
		configFileBodyDir = string("");
		configFileBodyFile = configFileBodyTmp;
	}
	else
	{
		configFileBodyDir = string(configFileBodyTmp, 0, ind+1);
		configFileBodyFile = string(configFileBodyTmp, ind+1);
	}



	// initialisation CUDA environment
	std::cout<<"initialisation of GPU environnement"<<std::endl;
	//cublasHandle_t cublasHandle;
	Faust::BlasHandle<Gpu> blasHandle;
	blasHandle.Init();

	//cusparseHandle_t cusparseHandle;
	Faust::SpBlasHandle<Gpu> spblasHandle;
	spblasHandle.Init();


	std::cout<<"initialisation of HierarchicalFact parameter"<<std::endl;
	
	// parameter setting	
	Faust::Params<FPP,Gpu> params;
	std::cout<<"init_params"<<std::endl;
	init_params_from_matiofile(params,configFilename.c_str(),"params");
	std::cout<<"Display2"<<std::endl;
	params.Display();
	cout<<"launch"<<endl;

	// matrix to be factorized
	Faust::MatDense<FPP,Gpu> matrix;
	init_faust_mat_from_matio(matrix,MatrixFilename.c_str(),"matrix");

	//algorithm
	Faust::HierarchicalFact<FPP,Gpu> hierFact(matrix,params,blasHandle,spblasHandle);

	std::cout<<"factorisation"<<std::endl;
	Faust::Timer_gpu t1;
	t1.start();

	hierFact.compute_facts();

	t1.stop();
	#ifdef __COMPILE_TIMERS__
		hierFact.print_timers();
	#endif
	cout <<"total hierarchical fact = "<<t1.get_time()<<endl;

	vector<Faust::MatSparse<FPP,Gpu> > facts;
	hierFact.get_facts(facts);

	FPP lambda=hierFact.get_lambda();
	cout<<"lambda="<<std::setprecision(20)<<lambda<<endl<<endl;

		/// equality test between lambda (multiplied scalar and lambda)
	if (argc >= 3)
	{
		if (std::abs(lambda - expectedLambda) > epsilon)
		{
			std::cerr<<"invalid lambda, must be equal to "<<std::setprecision(20)<<std::setprecision(20)<<expectedLambda<<" in the precision of "<<epsilon<<std::endl;
			std::cerr<<"current value is "<<std::setprecision(20)<<lambda<<std::endl;
			exit(EXIT_FAILURE);
		}

	}



	//Faust::Transform_cu<FPP> hierFactCore(facts);
	Faust::Transform<FPP,Gpu> hierFactCore(facts,lambda);


	//write the given factorisation into a mat file
	stringstream outputFilename;
	outputFilename<<"@FAUST_BIN_TEST_OUTPUT_DIR@/"<<configFileBodyFile<<"_gpu_factorisation.mat";
	std::cout<<"**************** WRITING FACTORISATION INTO ****************"<<std::endl;
	std::cout<<"output filename : "<<outputFilename.str();
	write_faust_core_into_matfile(hierFactCore,outputFilename.str().c_str(),"fact");

	//relativeError
	Faust::MatDense<FPP,Gpu> const dataMatrix(matrix);
	Faust::MatDense<FPP,Gpu> tmp;
	tmp=hierFactCore.get_product(blasHandle,spblasHandle);
	Faust::MatDense<FPP,Gpu> const faustProduct(tmp);
	Faust::MatDense<FPP,Gpu> error(faustProduct);
	error-=dataMatrix;
	FPP relativeError = error.norm()/dataMatrix.norm();

	std::cout<<std::endl;
	std::cout<<"**************** RELATIVE ERROR BETWEEN FAUST AND DATA MATRIX **************** "<<std::endl;
	std::cout<<"		"<<relativeError<<std::endl<<std::endl;


	//time comparison between matrix vector product and faust-vector product
	int niterTimeComp = 100;
	if (niterTimeComp > 0)
	{

		Faust::Timer_gpu tdense;
		Faust::Timer_gpu tfaust;
		Faust::Vect<FPP,Gpu> x(dataMatrix.getNbCol());
		Faust::Vect<FPP,Gpu> ydense(dataMatrix.getNbRow());
		Faust::Vect<FPP,Gpu> yfaust(hierFactCore.getNbRow());
		Faust::Vect<FPP,Gpu> ycomp(faustProduct.getNbRow());

		x.setOnes();


		for (int i=0;i<niterTimeComp;i++)
		{

			tdense.start();
			Faust::gemv(dataMatrix,x,ydense,'N',blasHandle);
			tdense.stop();

			Faust::gemv(faustProduct,x,ycomp,'N',blasHandle);

	 		tfaust.start();
			hierFactCore.mult(x,yfaust,spblasHandle);
			tfaust.stop();
			if(!yfaust.equality(ycomp))
			{
				cout<<"ycomp"<<std::endl<<std::endl;
				yfaust.Display();
				cout<<std::endl<<std::endl<<"yfaust"<<std::endl;
				ycomp.Display();
				cerr << "vector multiplication issue : yfaust (multiplication by faust) and ycomp (multiplication by the dense matrix representing the faust)  are not equal with the given precision"<<epsilon<< endl;
				exit(EXIT_FAILURE);
			}

	 	}


		std::cout<<std::endl;

		std::cout<<"**************** TIME COMPARISON MATRIX VECTOR PRODUCT **************** "<<std::endl;
		std::cout<<"	TIME  SPEED-UP : "<<tdense.get_time()/tfaust.get_time()<<std::endl;
		std::cout<<"	MEAN TIME dense : "<<tdense.get_time()/((float) niterTimeComp)<<std::endl;
		std::cout<<"	MEAN TIME faust : "<<tfaust.get_time()/((float) niterTimeComp)<<std::endl;
	}


	blasHandle.Destroy();
	spblasHandle.Destroy();

	return 0;
}

